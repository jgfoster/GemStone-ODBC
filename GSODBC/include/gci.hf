#ifndef GCI_HF
#define GCI_HF TRUE
/*=========================================================================
 * Copyright (C) GemTalk Systems 1986-2016.  All Rights Reserved.
 *
 * Name - gci.hf
 *
 * Description - Functional interface to the GemBuilder for C interface (GCI).
 *               This interface used to be called the GemStone C Interface.
 *               This header file should be used by applications that
 *               specify what version of the GCI library to use when
 *               they are built.
 *
 *  This file defines the entry points for the non-thread-safe legacy GCI
 *
 * $Id: gci.hf 36473 2015-06-01 16:32:16Z otisa $
 *
 *========================================================================
 */
#include "flag.ht"
#include "l2unix.hf"
#include <setjmp.h>

#ifdef GCIUA_HF
+++ error Include gci.hf or gciua.hf, not both.
#endif

#include "gcicmn.ht"
#include "gcilegacy.ht"

#include "gcirtl.hf"

#if defined(OOP_HT)
+++ illegal include of oop.ht prior to gci.hf
#endif

/* the following were in the generated file gcirtl.ht in 2.x */
#if defined (FLG_MSWIN32)
#include <windows.h>
#include <stdio.h>
typedef void* sigset_t;
#if !defined(_AMD64_)
// defined in crtdefs.h on 64-bit windows
typedef int intptr_t;
#endif
#if !defined(GLOBAL_HT) || !defined(_AMD64_)
typedef SSIZE_T ssize_t;
#endif
#endif

/*******  Variables defined in this module  *********************************/
/* No external variables are permitted in this interface.
 */
 
#if !defined(UTL_HT)
class GciCTimeStringType {
 public:
  char msg[100];
  GciCTimeStringType() { msg[0] = '\0'; } 
};
#endif



extern "C" {
  // functions used within the GCI implementation

#if defined(FLG_UNIX)
typedef void GciKbIntFType(int sig);
#else
typedef void GciKbIntFType(void);
#endif

typedef void GciFaultFuncType(void);

typedef void GciErrMsgPrintFType(const char* msg);

typedef void GciErrMsgObjPrintFType(GciErrMsgPrintFType *printer, OopType o);

} /* extern "C" */

// Following functions are declared   extern "C" for compatibility with GBS

extern "C" {

/* =============================================================================
 * GciAbort function
 *   Abort the current transaction.
 *
 * An abort operation should always succeed, and thus this function generates 
 * no errors.
 * Equivalent to  GciExecuteStr ("System abortTransaction", OOP_NIL);
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciAbort(void);

/* =============================================================================
 * GciAddOopToNsc function
 *   Add an OOP to the unordered variables of a non-sequenceable collection.
 *
 * Input Arguments:
 *   theNsc	The OOP of the NSC.
 *   theOop	The OOP to be added.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciAddOopToNsc(OopType theNsc, OopType theOop);

/* =============================================================================
 * GciAddOopsToNsc function
 *   Add multiple OOPs to the unordered variables of a non-sequenceable
 *   collection.
 *
 * Input Arguments:
 *   theNsc	The OOP of the NSC.
 *   theOops	An array of OOPs to be added.
 *   numOops	The number of OOPs to add.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciAddOopsToNsc(
  OopType theNsc, const OopType theOops[],
  int numOops);

// deleted GciAddSaveObjsToReadSet
// fixed 34038

/*========================================================================
 * GciAlteredObjs
 *    
 *    GciAlteredObjs destructively enumerates both the 
 *    ExportedDirtyObjs and TrackedDirtyObjs sets .
 *
 *    This entry point returns a list of Objects which are in either 
 *    the PureExportSet or the GciTrackedObjs, and are dirty.  
 *
 *    Dirty means
 *         an object whose state has been changed by one of the following:
 *         a.  GemStone Smalltalk execution,
 *         b.  Calls to GciStorePaths, GciSymDictAtObjPut, GciSymDictAtPut,
 *               GciStrKeyValueDictAtObjPut, GciStrKeyValueDictAtPut
 *         c.  Any GCI call from within a user action.
 *         d.  Committed by another transaction if a commit or abort
 *             was executed.
 *         e.  Aborted the modified state of a committed object.
 *
 *    Calls to GciStore* (other than GciStorePaths), GciAppend*,
 *    GciReplace*, and GciCreate*  do NOT put the modified object into
 *    the set of dirty objects.  The assumption is that the client does not
 *    want the dirty set to include modifications that the client has 
 *    explicitly made.  EXCEPTION:  GciStore*, etc, calls from within
 *    a user action WILL put the modified object into the set of dirty
 *    objects.
 *
 *    The application designer must ensure that the PureExportSet in 
 *    GemStone contains all objects they have cached (see GciSaveObjs).  
 *
 *    The numOops argument is used as both an input and an output parameter.
 *    On input the value of numOops should be set to the maximum number of
 *    oops that can be returned in this call, i.e., the size (in oops)
 *    of the buffer specified by the first argument.  On output the numOops
 *    argument is set to the number of oops returned in the buffer.
 *
 *    The function result indicates whether the operation of returning
 *    the dirty objects is done.  If either is not done,
 *    i.e. FALSE, it is expected that the user will make repeated calls to 
 *    this function until it returns a TRUE to indicate that all of the 
 *    dirty objects have been returned.  If repeated 
 *    calls are not made, then the unreturned objects will persist in the 
 *    list until the function is next called.
 *
 *    GciDirtyObjsInit() must be called once after login before
 *    GciAlteredObjs() can be used.
 *
 *========================================================================
 */
EXTERN_GCI_DEC(BoolType) GciAlteredObjs(
  OopType theOops[], int *numOops);


/* =============================================================================
 * GciAppendBytes function
 *   Append bytes to a byte object.
 *
 * Input Arguments:
 *   theObject	A byte object to which bytes are to be appended.
 *   numBytes	The number of bytes to be appended.
 *   theBytes	A pointer to the bytes to be appended.
 *
 * Equivalent to 
 *   GciStoreBytes(theObject, GciFetchSize(theObject)+1, theBytes, numBytes)
 *
 * May not be used on instances of OOP_CLASS_FLOAT or OOP_CLASS_SMALL_FLOAT.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciAppendBytes(
  OopType theObject, int64 numBytes,
  const ByteType *theBytes
    );

/* =============================================================================
 * GciAppendChars function
 *   Append a C string to a byte object.
 *
 * Input Arguments:
 *   theObject	A byte object to which the string is to be appended.
 *   aString	A pointer to the string to be appended.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciAppendChars(OopType theObject, const char* aString);

/* =============================================================================
 * GciAppendOops function
 *   Append OOPs to the unnamed variables of a collection.
 *
 * Input Arguments:
 *   theObject	A collection to which additional OOPs are to be added.
 *   numOops	The number of OOPs to be added.
 *   theOops	A pointer to the OOPs to be added.
 *
 * Equivalent to 
 *   GciStoreOops(theObject, GciFetchSize(theObject)+1, theOops, numOops)
 * or
 *   GciAddOopsToNsc(theObject, theOops, numOops)
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciAppendOops(
  OopType theObject, int numOops,
  const OopType *theOops
    );

/* =============================================================================
 * GciBegin function
 *
 *  Aborts the current transaction and starts a new transaction.
 *
 *  Equivalent to     GciExecuteStr ("System beginTransaction", OOP_NIL)
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciBegin(void);

/* =============================================================================
 * GciCallInProgress function
 *   Determine if a GCI call is currently in progress.
 *
 *   Intended to be used within interrrupt handlers to determine whether
 *   a Gci call is currently in progress.
 *   May be called any time after GciInit has been called.
 *
 *   If the process is currently executing within a user action, and
 *   the user action code is not within a re-entrant Gci call, this
 *   function will return FALSE.  Note that GciInUserAction is available
 *   to determine if you are within a user action.
 *
 * Return Value:
 *   This function returns TRUE if a GCI call is in progress, and FALSE
 *   otherwise.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciCallInProgress(void);

/* =============================================================================
 * GciCheckAuth function
 *   Gather the current authorizations for an array of database objects.
 *
 * Input Arguments:
 *   oopArray   An array of OOPs of objects for which the user's authorization
 *              level is to be ascertained.  The caller must provide these
 *              values.
 *   arraySize  The number of OOPs in oopArray.
 *
 * Result Arguments:
 *   authCodeArray
 *              The resulting array, having at least arraySize elements, in
 *              which the authorization values of the objects in oopArray are
 *              returned as 1-byte integer values.
 *
 * For each object in oopArray up to arraySize, this function checks the
 * authorization for the current user.  Stores the authorization for each
 * input object in authCodeArray.  The result is represented as:
 *
 *   1  no authorization
 *   2  read authorization
 *   3  write authorization
 *
 * The authorization reported for each object is the result of a complete
 * authorization check, including owner, group, and world authorization(s).
 * "Special objects" such as SmallIntegers will always be reported as
 * "read authorization".
 *
 * Reports an error if any member of oopArray is not a legal oop. If such
 * an error is reported, then the contents of authCodeArray are undefined.
 * The user is responsible for allocating enough room in authCodeArray to
 * hold the results.
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void)
GciCheckAuth(
   const OopType *oopArray, int arraySize, unsigned char *authCodeArray
  );


/* =============================================================================
 * GciClampedTraverseObjs function
 *   Traverse an array of objects, subject to clamps.
 *
 *  Deprecated. New code should use GciClampedTrav .          (fix 44138)
 * 
 * Input Arguments:
 *   clampSpec	The OOP of the ClampSpecification to be used,
 *              or OOP_NIL (in which case this function is equivalent to
 *                     GciTraverseObjs).
 *              Refer to the GemStone Kernel Reference for a description of 
 *              ClampSpecification.
 *   theOops	An array of OOPs representing the objects to traverse.
 *   numOops	The number of elements in theOops.
 *   travBuffSize
 *              The size of the traversal buffer (in bytes).
 *   level	Maximum traversal depth.  When the level is 1, an object report
 *              is written to the traversal buffer for each element in theOops.
 *              When level is 2, an object report is also obtained for the
 *              instance variables of each level-1 object. When level is 0, the
 *              number of levels in the traversal is not restricted.
 *
 * Result Arguments:
 *   travBuff	The buffer for the results of the traversal.  The first element
 *              placed in the buffer is the actualBufferSize, an int64
 *              that indicates how many bytes were actually stored in the buffer
 *              by this function.  The remainder of the traversal buffer
 *              consists of a series of object reports, each of which is of type
 *              GciObjRepSType.
 *
 *        Gemstone64 addition:
 *                If a given object report represents a clamped object, the
 *                report will have valueBuffSize==0 .  The idxSize field
 *                in the report will be filled in with the varyingSize for
 *                simple objects like Array, String, IdentityBag, IdentitySet , and
 *                for some kinds of AbstractDictionary.  The idxSize field
 *                will always be zero for some kinds of Rc classes .
 *              
 *              If the report array would be empty, a single object report 
 *              is created for the object nil.
 *
 *   Note:  object reports for kinds of Bag, Set, and AbstractDictionary
 *          are composed based on a logical traversal of the elements
 *          (objects, key/value pairs, or Associations as appropriate), not
 *          based on a structural dump of the object.
 *
 * Return Value:
 *   Returns FALSE if the traversal is not yet completed, but further traversal
 *   would cause the travBuffSize to be exceeded.  If the travBuffSize is
 *   reached before the traversal is complete, you can subsequently call
 *   GciMoreTraversal to continue the operation from the point where
 *   travBuffSize was exceeded.
 *
 *   Returns TRUE if there are no more objects to be returned by subsequent
 *   calls to GciMoreTraversal (that is, an object report was constructed for
 *   each object, minus the special objects).
 *
 * For more information, see the GCI manual.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciClampedTraverseObjs(
  OopType clampSpec,
  const OopType theOops[], int numOops,
  GciTravBufType *travBuff, int level
    );

/* =============================================================================
 * GciClampedTrav function
 *   Traverse an array of objects, subject to clamps.
 *
 * Input Arguments:
 *   theOops	An array of OOPs representing the objects to traverse.
 *   numOops	The number of elements in theOops.
 *
 *   *args , an instance of GciClampedTravArgsSType (see gci.ht) 
 *
 *   args->clampSpec   OOP of a ClampSpecification to be used,
 *              or OOP_NIL, if the traversal is to operate without clamping.
 *              Refer to the GemStone Kernel Reference for a description of 
 *              the class ClampSpecification.
 *
 *   args->travBuffSize   The size of the traversal buffer (in bytes).
 *
 *   args->level	Maximum traversal depth.  
 *              When the level is 1, an object report
 *              is written to the traversal buffer for each element in theOops.
 *              When level is 2, an object report is also obtained for the
 *              instance variables of each level-1 object. When level is 0, the
 *              number of levels in the traversal is not restricted.
 *
 *   args->retrievalFlags
 *              If (args->retrievalFlags & GCI_RETRIEVE_EXPORT) != 0 
 *	        then oops of non-special objects for which an object report
 *              header is returned in the traversal buffer will automatically 
 *              be added to an export set using GciSaveObjs semantics. 
 *              Oops are added to the user action's export set if GciClampedTrav
 *              is called from within a user action, otherwise they are
 *              added to the session's  PureExportSet  .
 *
 *   args->isRpc    ignored; for internal use by implementation of GCI.
 *
 * Result Arguments:
 *   args->travBuff	
 *              The buffer for the results of the traversal.  The first element
 *              placed in the buffer is the actualBufferSize, an int64
 *              that indicates how many bytes were actually stored in the buffer
 *              by this function.  The remainder of the traversal buffer
 *              consists of a series of object reports, each of which is of type
 *              GciObjRepSType.
 *              You can use the macro GCI_IS_REPORT_CLAMPED to find out if a
 *              given object report represents a clamped object.  If the report
 *              array would be empty, a single object report is created for the
 *              object nil.
 *
 *   Note:  object reports for kinds of Bag, Set, and AbstractDictionary
 *          are composed based on a logical traversal of the elements
 *          (objects, key/value pairs, or Associations as appropriate), not
 *          based on a structural dump of the object.
 *
 * Return Value:
 *   Returns FALSE if the traversal is not yet completed, but further traversal
 *   would cause the travBuffSize to be exceeded.  If the travBuffSize is
 *   reached before the traversal is complete, you can subsequently call
 *   GciMoreTraversal to continue the operation from the point where
 *   travBuffSize was exceeded.
 *
 *   Returns TRUE if there are no more objects to be returned by subsequent
 *   calls to GciMoreTraversal (that is, an object report was constructed for
 *   each object, minus the special objects).
 *
 * For more information, see the GCI manual.
 *==============================================================================
 */

  GCI_ALIGN_STACK EXTERN_GCI_DEC(BoolType) 
GciClampedTrav(
  const OopType *theOops, int numOops,
  GciClampedTravArgsSType *args
  );


/* =============================================================================
 * GciClassMethodForClass function
 *   Compile a class method for a class.
 *
 * Input Arguments:
 *   source	The OOP of a GemStone Smalltalk string to be compiled as a class
 *              method.
 *   oclass	The OOP of the class with which the method is to be associated.
 *
 *   category	The OOP of a GemStone Smalltalk string, which contains the 
 *     name of the category to which the method is added.  
 *     If the category is nil (OOP_NIL), the compiler will add this 
 *     method to the category "(as yet unclassified)".
 *
 *   symbolList	The OOP of a GemStone symbol list (that is, an Array of
 *     instances of SymbolDictionary).  GemStone Smalltalk resolves 
 *     symbolic references in source code by using symbols that are available
 *     from symbolList.  A value of OOP_NIL means to use the default
 *     symbol list for the current GemStone session (that is,
 *     System myUserProfile symbolList).
 *
 *   environmentId  a compilation environment identifier , zero for Smalltalk
 *
 *   If compilation errors occur, an error is generated.
 *
 *   Function result: OOP_NIL, or oop of a String containing warning messages
 *
 *   If a SessionMethodsDict has been installed (via 
 *     GsCurrentSession>>_installSessionMethodDict:), the compiler is invoked
 *     by calling Behavior>>compileMethod:dictionaries:category:, in which case
 *     no warnings are generated.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciClassMethodForClass(OopType source, OopType oclass, OopType category,
  OopType symbolList);

/* =============================================================================
 * GciClassNamedSize function
 *   Find the number of named instance variables in a class.
 *
 * Input Arguments:
 *   oclass	The OOP of the class from which to obtain information about
 *              instance variables.
 *
 * Return Value:
 *   Returns the number of named instance variables in the class.  In case of
 *   error, this function returns zero.
 *==============================================================================
 */
  EXTERN_GCI_DEC(int) 
GciClassNamedSize(OopType oclass);

/* =============================================================================
 * GciClearStack function
 *   Clear the GemStone Smalltalk call stack.
 *
 * Input Arguments:
 *   aGsProcess	The OOP of a GsProcess object (obtained as the value of the
 *              context field of an error report returned by GciErr).
 *
 * Gs64 v3.0:  If GciClearStack is called from a user action and process
 * is the GsProcess which invoked that user action, the stack is only cleared
 * back to the frame representing entry into the user action.
 * Otherwise GciClearStack is equivalent to GciPerform(aGsProcess, "terminate9", NULL, 0);
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciClearStack(OopType aGsProcess);

/* =============================================================================
 * GciCommit function
 *   Write the current transaction to the database.
 *
 * Return Value:
 *   Returns TRUE if the transaction committed successfully.  Returns FALSE if
 *   the transaction fails to commit due to a concurrency conflict or in case of
 *   error.
 *
 * Similar to the expression
 *    GciExecuteStr("System commitTransaction", OOP_NIL) == OOP_TRUE
 * except that GciCommit does not generate pending commit/abort errors.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciCommit(void);

/* =============================================================================
 * GciContinue function
 *   Continue code execution in GemStone after an error.
 *
 * Input Arguments:
 *   process	The OOP of a Process object (obtained as the value of the
 *              context field of an error report returned by GciErr).
 *
 * Return Value:
 *
 *   Equivalent to GciContinueWith(process, OOP_ILLEGAL, 0, NULL);
 *
 *   Returns the OOP of the result of the GemStone Smalltalk code that was 
 *   executed. Returns OOP_NIL in case of error.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciContinue(OopType process);

/* =============================================================================
 * GciContinueWith function
 *   Continue code execution in GemStone after an error.
 *
 * Input Arguments:
 *   process - The OOP of a Process object (obtained as the value of the
 *             context field of an error report returned by GciErr).
 *
 *   replaceTopOfStack - If not OOP_ILLEGAL, replace the top of the
 *        Smalltalk evaluation stack with  this value before continuing.
 *     Gs64 v3.0:  If OOP_ILLEGAL, and top frame is AbstractException>>signal,
                   then TOS replaced with OOP_NIL ,
 *                 to be consistent with  AbstractException>>resume .
 *
 *   flags - same semantics as flags argument to GciPerformNoDebug .
 *
 *   *error -  if not NULL, continue with an error. takes 
 *                      precedence over replaceTopOfStack .
 *             Top frame of stack must be AbstractException>>signal 
 *                 or   AbstractException >>_signalFromPrimitive .
 *             Within *error, if error->exceptionObj is not OOP_NIL
 *             it is used to replace self in the top frame,
 *             otherwise error->number is used to construct a kind of
 *             AbstractException to replace self in the top frame.
 *             Then execution is restarted at start of top frame's method.
 *
 * Return Value:
 *   Returns the OOP of the result of the GemStone Smalltalk code that was 
 *   executed. Returns OOP_NIL in case of error.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciContinueWith(
  OopType process, 
  OopType replaceTopOfStack, 
  int flags,  /* same as GciPerformNoDebug flags, but single step has
			no effect */
  GciErrSType *error
);

  EXTERN_GCI_DEC(void) 
GciNbContinueWith(
  OopType process, 
  OopType replaceTopOfStack, 
  int flags,  /* same as GciPerformNoDebug flags, but single step has
			no effect */
  GciErrSType *error
);


/*========================================================================
 *  GciCreateOopObj, GciCreateByteObj
 *
 *  Creates a new object using an object identifier previously obtained from
 *  GciGetFreeOop.  See comments under GciGetFreeOop for a further
 *  discussion of semantics of such identifiers.
 *
 *  GciCreateOopObj is for use with classes whose instances are Nsc or Oop format.
 *  GciCreateByteObj is for use with classes whose instances are Byte format.
 *
 *  arguments:  
 *     oclass - the oop of the class of the new object
 *     objId  - oop of the new object, 
 *       must be an oop obtained from GciGetFreeOop, or OOP_ILLEGAL may be
 *       passed in which case GciCreate* will assign a new oop and return
 *       that oop as the function result.  If creating a Symbol or
 *       DoubleByteSymbol,  objId must be OOP_ILLEGAL .
 *     *values - array of instance variable values
 *     numValues - number of elements in *values
 *     clusterId - id of ClusterBucket in which to place the object
 *
 *  function result
 *     the oop of the object created. equal to objId argument unless that
 *     argument was OOP_ILLEGAL
 *
 *  semantics of numValues - if oclass is an indexable or Nsc class, then
 *    numValues may be as large or as small as desired.  If oclass is
 *    not indexable nor Nsc, then it is an error if numValues is greater than
 *    the number of named instance variables.  For certain classes of byte
 *    format, namely DateTime, Float, LargePositiveInteger, and
 *    LargeNegativeInteger, additional size restrictions apply.
 *
 *  semantics of *values -  values are stored into the object starting at
 *    the first named instance variable (if any) and continuing to the
 *    indexable (or Nsc) instance variables if oclass is indexable (or nsc).
 *
 *   For OopType *values, values may be forward references to objects whose
 *    identifier has been allocated with GciGetFreeOop, but for which
 *    the object has not yet been created with GciCreate .  However
      it is illegal to create a forward reference to a Symbol. Thus
      a GciCreate which creates a Symbol will fail if the client's objId  
      of the created object was already used as a forward reference.
 *
 *  The caller must initialize any unused elements of *values to OOP_NIL.
 *
 *  If oclass defines indexable objects, numValues may be greater than
 *  the number of named instance variables.  If numValues is less than
 *  number of named instance variables, then any instance variables beyond
 *  numValues will be initialized to OOP_NIL.
 *
 *  For an indexable object,if numValues is greater than zero and
 *  values == NULL, then the object will be created of size numValues, and
 *  will be initialized to logical size numValues. This is equivalent to
 *   new: aSize for classes Array or String.
 *
 *  If oclass defines indexable objects, then numValues may be greater than
 *  the number of named instance variables.   If numValues is less than
 *  number of named instance variables, the object will be created of size
 *  number of named instance variables.
 *
 *  The object is created in temporary object 
 *  space, and the garbage collecter will make it permanent if the object is or
 *  becomes referenced by another permanent object. 
 *
 *  clusterId may be
 *     0 - indicates use  the cluster bucket    (System currentClusterId)
 *     a positive integer <= GciFetchSize(OOP_ALL_CLUSTER_BUCKETS)
 *  values of clusterId outside of the above range will generate an error
 *
 *  If GciCreateByteObj is being used to create an instance of 
 *   OOP_CLASS_FLOAT or OOP_CLASS_SMALL_FLOAT, then the correct number of
 *   value bytes must be supplied at the time of creation.
 * ===================================================================
 */

  EXTERN_GCI_DEC(OopType) 
GciCreateOopObj(
  OopType oclass, OopType objId, const OopType *values,
  int numValues, int clusterId,
  BoolType makePermanent/* has no effect*/ );

  EXTERN_GCI_DEC(OopType) 
GciCreateByteObj(
  OopType oclass, OopType objId, const ByteType *values,
  int64 numValues, int clusterId,
  BoolType makePermanent/* has no effect*/
    );
/*========================================================================
 * GciDirtyExportedObjs
 *    
 *    This entry point returns a list of objects which are in the 
 *    ExportedDirtyObjs, i.e. objects in the PureExportSet and whose state
 *    has been changed by one of the following:
 *        1.  Smalltalk execution,
 *        2.  Calls to GciStorePaths, GciSymDictAtObjPut, GciSymDictAtPut,
 *              GciStrKeyValueDictAtObjPut, GciStrKeyValueDictAtPut
 *        3.  Any GCI call from within a user action.
 *        4.  Committed by another transaction if a commit or abort
 *            was executed.
 *        5.  Aborted the modified state of a committed object.
 *
 *    GciDirtyObjsInit() must be called once after login before
 *    GciDirtyExportedObjs() can be used.
 *    This function does a destructive enumeration of ExportedDirtyObjs.
 *
 *    Calls to GciStore* (other than GciStorePaths), GciAppend*,
 *    GciReplace*, and GciCreate*  do NOT put the modified object into
 *    the set of dirty objects.  The assumption is that the client does not
 *    want the dirty set to include modifications that the client has 
 *    explicitly made.  EXCEPTION:  GciStore*, etc, calls from within
 *    a user action WILL put the modified object into the set of dirty
 *    objects.
 *
 *    The numOops argument is used as both an input and an output parameter.
 *    On input the value of numOops should be set to the maximum number of
 *    oops that can be returned in this call, i.e., the size (in oops)
 *    of the buffer specified by the first argument.  On output the numOops
 *    argument is set to the number of oops returned in the buffer.
 *
 *    The function result indicates whether the operation of returning
 *    the dirty objects is done.  If not done, i.e. FALSE, it is expected
 *    that the user will make repeated calls to this function until it
 *    returns a TRUE to indicate that all of the dirty objects have been
 *    returned.  If repeated calls are not made, then the unreturned objects
 *    will persist in the list until the function is next called.
 *
 *========================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciDirtyExportedObjs(OopType theOops[], int *numOops);

/*========================================================================
 * GciDirtyTrackedObjs
 *    
 *    This entry point returns a list of objects which are in the 
 *    TrackedDirtyObjs set, i.e., objects which are in the GciTrackedObjs set
 *    and whose state has been changed by one of the following:
 *        1.  Smalltalk execution,
 *        2.  Calls to GciStorePaths, GciSymDictAtObjPut, GciSymDictAtPut,
 *              GciStrKeyValueDictAtObjPut, GciStrKeyValueDictAtPut
 *        3.  Any GCI call from within a user action.
 *        4.  Committed by another transaction if a commit or abort
 *            was executed.
 *        5.  Aborted the modified state of a committed object.
 *
 *    GciTrackedObjsInit() must be called once after login before
 *    GciDirtyTrackedObjs() can be used.
 *    This function does a destructive enumeration of TrackedDirtyObjs.
 *
 *    Calls to GciStore* (other than GciStorePaths), GciAppend*,
 *    GciReplace*, and GciCreate*  do NOT put the modified object into
 *    the set of dirty objects.  The assumption is that the client does not
 *    want the dirty set to include modifications that the client has 
 *    explicitly made.  EXCEPTION:  GciStore*, etc, calls from within
 *    a user action WILL put the modified object into the set of dirty
 *    objects.
 *
 *    The numOops argument is used as both an input and an output parameter.
 *    On input the value of numOops should be set to the maximum number of
 *    oops that can be returned in this call, i.e., the size (in oops)
 *    of the buffer specified by the first argument.  On output the numOops
 *    argument is set to the number of oops returned in the buffer.
 *
 *    The function result indicates whether the operation of returning
 *    the dirty objects is done.  If not done, i.e. FALSE, it is expected
 *    that the user will make repeated calls to this function until it
 *    returns a TRUE to indicate that all of the dirty objects have been
 *    returned.  If repeated calls are not made, then the unreturned objects
 *    will persist in the list until the function is next called.
 *
 *========================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciDirtyTrackedObjs(OopType theOops[], int *numOops);


/*========================================================================
 * GciDirtyObjsInit
 *    Reinitializes the ExportedDirtyObjs set .
 *    Must be called before GciDirtySaveObjs to enable the collection of
 *    dirty objects.
 *
 *  Once this function has been called,
 *   the methods   System|commitTransaction
 *       and       System|abortTransaction
 *  will generate the error RT_ERR_COMMIT_ABORT_PENDING prior to the
 *   attempt to commit or prior to the abort, respectively.
 *========================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciDirtyObjsInit(void);

/*========================================================================
 * GciDirtySaveObjs
 *    
 *    This entry point returns a list of objects which are 
 *    either in the ExportedDirtyObjs or TrackedDirtyObjs sets.
 *
 *    GciDirtySaveObjs destructively enumerates both the 
 *    ExportedDirtyObjs and TrackedDirtyObjs sets .
 *
 *    The application designer must ensure that the SaveObjectsSet in 
 *    GemStone contains all of the objects they have cached (see GciSaveObjs).  
 *
 *    The numOops argument is used as both an input and an output parameter.
 *    On input the value of numOops should be set to the maximum number of
 *    oops that can be returned in this call, i.e., the size (in oops)
 *    of the buffer specified by the first argument.  On output the numOops
 *    argument is set to the number of oops returned in the buffer.
 *
 *    The function result indicates whether the operation of returning
 *    the dirty objects is done.  If not done, i.e. FALSE, it is expected
 *    that the user will make repeated calls to this function until it
 *    returns a TRUE to indicate that all of the dirty objects have been
 *    returned.  If repeated calls are not made, then the unreturned objects
 *    will persist in the list until the function is next called.
 *
 *   See also GciDirtyExportedObjs() , GciDirtyTrackedObjs() .
 *          
 *========================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciDirtySaveObjs(OopType theOops[], int *numOops);


/* =======================================================================
 * GciDateTime entry points
 * =======================================================================
 */

/* =============================================================================
 * GciNewDateTime function
 *   Create and initialize a new date-time object.
 *
 * Input Arguments:
 *   theClass	The class of the object to be created.  theClass must be
 *              OOP_CLASS_DATE_TIME or a subclass thereof.
 *   timeVal	The time value to be assigned to the newly-created object.
 *
 * Return Value:
 *   Returns the OOP of the newly-created object.  If an error occurs, returns
 *   OOP_ILLEGAL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciNewDateTime(OopType theClass, const GciDateTimeSType *timeVal);

/* =============================================================================
 * GciFetchDateTime function
 *   Convert the contents of a DateTime object and place the results in a
 *   C structure.
 *
 * Input Arguments:
 *   datetimeObj	OOP of the object to fetch.
 *
 * Result Arguments:
 *   result		C pointer to the structure for the returned object.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciFetchDateTime(OopType datetimeObj, GciDateTimeSType *result);

/* =============================================================================
 * GciDateTimeToCTime function
 *   Convert a GemStone date-time representation to C's.
 *
 * Input Arguments:
 *   arg	An instance of GciDateTimeSType to be converted.
 *
 * Return Value:
 *   A C time value of type time_t.
 *==============================================================================
 */
  EXTERN_GCI_DEC(time_t) 
GciDateTimeToCTime(const GciDateTimeSType *arg);

/* =============================================================================
 * GciCTimeToDateTime function
 *   Convert a C date-time representation to GemStone's.
 *
 * Input Arguments:
 *   arg	The C time value to be converted.
 *
 * Result Arguments:
 *   result	A pointer to the C struct in which to place the converted value.
 *
 * Return Value:
 *   Returns TRUE if the conversion succeeds; otherwise returns FALSE.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciCTimeToDateTime(time_t arg, GciDateTimeSType *result);

/* =============================================================================
 * GciDbgEstablish function
 *   Specify the debugging function for the GCI to execute before 
 *   and after most calls to GCI functions.
 *
 * Input Arguments:
 *   newDebugFunc
 *      A pointer to a C function (the trace function) that will be called 
 *      before each subsequent GCI call. 
 *
 * Return Value:
 *   Returns a pointer to the newDebugFunc specified in the previous
 *   GciDbgEstablish call (if any).
 *
 * Tracing semantics:
 *
 *  The trace function will be called with a string argument containing  
 *  the name of the GCI call.  The trace function will not be called before 
 *  any of the following GCI functions or macros: GCI_ALIGN, GCI_BOOL_TO_OOP,
 *  GCI_CHR_TO_OOP, GCI_IS_REPORT_CLAMPED, GciErr, or
 *  GciDbgEstablish itself.
 *
 *  To shut off tracing, call GciDbgEstablish with NULL as the argument.
 *
 *  If GciShutdown is called, tracing will be shut off.
 *
 *  For RPC sessions only,
 *  the trace function will also be called at the end of most calls, 
 *  with a string containing the name of the GCI call and the number of 
 *  bytes sent and received.  The string is built with the C print format
 *     "%s, bytes sent %lu received %lu"  .
 *  The number of bytes sent and received are the total since the previous
 *  time that these statistics were passed to a trace function, or since
 *  the session logged in, if this is the first GCI call traced during
 *  the session.  
 *
 *  see also GciDbgEstablishToFile.
 *==============================================================================
 */
  EXTERN_GCI_DEC(GciDbgFuncType*) 
GciDbgEstablish(GciDbgFuncType *newDebugFunc);

/* =============================================================================
 * GciDbgEstablishToFile function
 *
 *  Cause trace information for most GCI functions is to be written
 *  to a file.  If the file already exists, it will be opened in append
 *  mode. If fileName is NULL and tracing is not active to a file
 *  trace information will be written to stdout.
 *
 *  Calling GciDbgEstablishToFile will supercede the effect of any preceeding
 *  calls to GciDbgEstablish or GciDbgEstablishToFile .
 *
 *  If tracing is active to a file, then calling GciDbgEstablishToFile 
 *  with NULL must be used to shutoff tracing to the file.
 *
 *  If GciShutdown is called, tracing will be shut off.
 *
 *  See GciDbgEstablish for a specification of the trace information generated.
 *
 *  Function result TRUE if file operation successful.
 *==============================================================================
 */

  GCI_ALIGN_STACK EXTERN_GCI_DEC(BoolType) 
GciDbgEstablishToFile(const char *fileName);

/* =============================================================================
 * GciDbgLogString
 *
 *   If GciDbgEstablish or GciDbgEstablishToFile have been called to
 *   activate tracing of Gci calls, pass the argument to the trace function.
 *   If tracing is not active, this function has no effect.
 *
 *==============================================================================
 */

/* ==========================================================================
 * GciEnableFreeOopEncoding
 *
 *	Enables run-length encoding of free oops sent between the gem and the
 *      gci client.  Increases CPU consumption on both the client and the gem,
 *      decreases number of bytes passed on the network.
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciEnableFreeOopEncoding(void);

/* ==========================================================================
 * GciEnableFullCompression
 *
 *	Enables full compression (both directions) between the client and the
 *      rpc gem, for subsequent logins.  Has no effect for linked sessions
 *      nor for the currently logged in sessions.
 * ==========================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciEnableFullCompression(void);

  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciDbgLogString(const char *message);

/* ==========================================================================
 * GciEnableSignaledErrors
 *
 *   The default state of any invocation of the Gci is that the GCI 
 *   will not respond to stone to gem signals for the following errors:
 *      RT_ERR_SIGNAL_ABORT,
 *      RT_ERR_SIGNAL_COMMIT, RT_ERR_SIGNAL_GEMSTONE_SESSION .
 *   This default state exists after successful GciInit, and  at the
 *   entry to any user action; in this state, the signalled errors are
 *   delivered only to executing Smalltalk methods, and then only if 
 *   such delivery has been enabled via appropriate methods in class System.
 *
 *   If this function is called with the argument TRUE,  then this GCI will
 *   check for the listed errors at the start of each GCI call that performs
 *   database access.  Note that the errors will only be delivered to the 
 *   GCI if they are enabled via appropriate methods in class System .  
 *   This function merely enables the GCI to have immediate visibility of 
 *   errors that have been enabled via executing the appropriate Smalltalk 
 *   methods.  The errors will be delivered via GciErr or via a longjmp if 
 *   a jmp_buf was active for the current session.
 *
 *   Checking for the signalled errors incurs no extra cost at runtime, 
 *   since the check is optimized into the check for valid session. 
 *
 *   Note that the error ABORT_ERR_LOST_OT_ROOT can never be suppressed.
 *   
 *   This function may not be called prior to GciLogin
 *
 *   Function result : TRUE if signalled errors previously enabled.
 * ==========================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciEnableSignaledErrors(BoolType newState);

/* ==========================================================================
 *  GciErr
 *    arguments: errorReport, address of a Gci error report structure
 *
 *    results:  function returns a boolean, as follows:
 *      TRUE indicates an error occurred. If errorReport is not NULL,
 *        *errorReport is filled in to contain the latest error 
 *        information. The internal error buffer in the Gci is cleared.  
 *        You can only call GciErr once for a given error.  
 *        If GciErr is called a second time, the function will return FALSE.
 *
 *      FALSE indicates no error occurred, and contents of *errorReport is
 *        unchanged.
 *
 *   If function result is TRUE,
 *     if error occurred during a StoreTravDoTravRefs or traversal with GCI_TRAV_WITH_REF_SET
 *       all objects referenced from *errorReport have been added to ReferencedSet
 *     else 
 *       all objects referenced from *errorReport have been added to PureExportSet
 * ==========================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(BoolType) 
GciErr(GciErrSType *errorReport);

/* ==========================================================================
 * GciFetchNumEncodedOops
 *
 * Return the total number of oops contained in an oop array which was
 * encoded by a call to GciEncodeOopArray.  The result of the function 
 * indicates the number of oops that will be decoded by a call to 
 * GciDecodeOopArray.
 *
 * ==========================================================================
 */
  EXTERN_GCI_DEC(int) 
GciFetchNumEncodedOops(OopType *encodedOopArray, const int numEncodedOops);

/* ==========================================================================
 * GciDecodeOopArray
 *
 * Decode the oops in oopArray which were run-length encoded using
 * GciEncodeOopArray and place the result in decodedOopArray.  
 *
 * The number of  oops placed in decodedOopArray is returned.  
 * The decodedOopArray size (as given by *decodedOopArraySize) must be
 * large enough to hold all decoded oops.  If it is not, no decode is 
 * performed and *decodedOopArraySize is set to -1.
 * ==========================================================================
 */
 EXTERN_GCI_DEC(int) 
GciDecodeOopArray(OopType *encodedOopArray,
                  const int numEncodedOops, 
                  OopType *decodedOopArray,
                  const int decodedOopArraySize);

/* ==========================================================================
 * GciEncodeOopArray
 *
 * Encode the oops in oopArray using run-length encoding.  Place the result
 * in encodedOopArray, Both oopArray and encodedOopArray must be arrayLength 
 * in size.  If the input array is known to be sorted in ascending order,
 * set needsSorting to FALSE, otherwise set it to TRUE.
 * Returns the number of elements in the encoded array.  
 * Returns -1 indicating an error if:
 *   -the input array was found to be out of sequence and needsSorting was
 *     set to FALSE.    
 * ==========================================================================
 */
  EXTERN_GCI_DEC(int) 
GciEncodeOopArray(OopType *oopArray, const int numOops, 
                  OopType *encodedOopArray, BoolType needsSorting);

/* =============================================================================
 * GciExecute, GciExecute_ functions
 *   Execute a Smalltalk expression contained in a String object.
 *
 * Input Arguments:
 *   source	The OOP of a String or Utf8 containing a sequence of one or more
 *              statements to be executed.
 *   symbolList	The OOP of a GemStone symbol list (that is, an Array of
 *              instances of SymbolDictionary).  The compiler uses the
 *              symbolList to resolve symbolic references in the code in source.
 *              A value of OOP_NIL means to use the default symbol list for the
 *              current GemStone session (that is, System myUserProfile
 *              symbolList).
 *
 *   environmentId specifies a compilation environment for the execution,
 *		normally zero for Smalltalk.
 *
 * Return Value:
 *   Returns the OOP of the execution result.  In case of error, this function
 *   returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciExecute(OopType source, OopType symbolList);

  EXTERN_GCI_DEC(OopType) 
GciExecute_(OopType source, OopType symbolList, ushort environmentId);


/* =============================================================================
 * GciExecuteDbg, GciExecuteDbg_ functions
 *   Execute a Smalltalk expression contained in a String object.
 *
 * Input Arguments:
 *   source     The OOP of a String or Utf8 containing a sequence of one or more
 *              statements to be executed.
 *   symbolList The OOP of a GemStone symbol list (that is, an Array of
 *              instances of SymbolDictionary).  The compiler uses the
 *              symbolList to resolve symbolic references in the code in source.
 *              A value of OOP_NIL means to use the default symbol list for the
 *              current GemStone session (that is, System myUserProfile
 *              symbolList).
 *
 *   flags      zero, or one of bits per GCI_PERFORM_FLAG* in gcicmn.ht
 *
 *   environmentId specifies a compilation environment for the execution,
 *              normally zero for Smalltalk
 *
 * Return Value:
 *   Returns the OOP of the execution result.  In case of error, this function
 *   returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciExecuteDbg(  OopType source, OopType symbolList, int flags);

  EXTERN_GCI_DEC(OopType) 
GciExecuteDbg_(  OopType source, OopType symbolList, int flags,  ushort environmentId );

/* =============================================================================
 * GciExecuteFromContext, GciExecuteFromContextDbg_ functions
 *   Execute a Smalltalk expression contained in a String object as if it
 *   were a message sent to another object.
 *
 * Input Arguments:
 *   source	The OOP of a String or Utf8 containing a sequence of one or more
 *              statements to be executed.
 *
 *   contextObject
 *		The OOP of any GemStone object.  The code to be executed is
 *              compiled as if it were an instance method in the class of
 *              contextObject.
 *              A value of OOP_NO_CONTEXT means no context.
 *
 *   symbolList	The OOP of a GemStone symbol list (that is, an Array of
 *              instances of SymbolDictionary).  The compiler uses the
 *              symbolList to resolve symbolic references in the code in source.
 *              A value of OOP_NIL means to use the default symbol list for the
 *              current GemStone session (that is, System myUserProfile
 *              symbolList).
 *
 *   environmentId specifies a compilation environment for the execution
 *
 *   flags      zero, or one of bits per GCI_PERFORM_FLAG* in gcicmn.ht
 *
 * Return Value:
 *   Returns the OOP of the execution result.  In case of error, this function
 *   returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciExecuteFromContext_(OopType source, OopType contextObject,
                      OopType symbolList , ushort environmentId);

  EXTERN_GCI_DEC(OopType) 
GciExecuteFromContextDbg_( OopType source, OopType contextObject,
  OopType symbolList , int flags,  ushort environmentId);

/* =============================================================================
 * GciExecuteFromContext, GciExecuteFromContextDbg functions
 * Input Arguments:
 *   source     The OOP of a String or Utf8 containing a sequence of one or more
 *              statements to be executed.
 *
 *   contextObject
 *              The OOP of any GemStone object.  The code to be executed is
 *              compiled as if it were an instance method in the class of
 *              contextObject.
 *              A value of OOP_NO_CONTEXT means no context.
 * 
 *   symbolList The OOP of a GemStone symbol list (that is, an Array of
 *              instances of SymbolDictionary).  The compiler uses the
 *              symbolList to resolve symbolic references in the code in source.
 *              A value of OOP_NIL means to use the default symbol list for the
 *              current GemStone session (that is, System myUserProfile
 *              symbolList).
 *
 *   flags      zero, or one of bits per GCI_PERFORM_FLAG* in gcicmn.ht
 *
 * Return Value:
 *   Returns the OOP of the execution result.  In case of error, this function
 *   returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciExecuteFromContext(OopType source, OopType contextObject,
                      OopType symbolList );

  EXTERN_GCI_DEC(OopType) 
GciExecuteFromContextDbg( OopType source, OopType contextObject,
  OopType symbolList , int flags  );

/* =============================================================================
 * GciExecuteStr, GciExecuteStr_, GciExecuteStrDbg_ functions
 *
 *   Execute a Smalltalk expression contained in a C string.
 *
 * Input Arguments:
 *   source	A null-terminated string containing a sequence of one or more
 *              statements to be executed, assumed to be 8 bit Ascii,
 *              will be used to create an instance of String .
 *
 *   symbolList	The OOP of a GemStone symbol list (that is, an Array of
 *              instances of SymbolDictionary).  The compiler uses the
 *              symbolList to resolve symbolic references in the code in source.
 *              A value of OOP_NIL means to use the default symbol list for the
 *              current GemStone session (that is, System myUserProfile
 *              symbolList).
 *
 *   flags      zero, or one of bits per GCI_PERFORM_FLAG* in gcicmn.ht
 *
 *   environmentId specifies a compilation environment for the execution,
 *              normally zero for Smalltalk
 *
 * Return Value:
 *   Returns the OOP of the execution result.  In case of error, this function
 *   returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciExecuteStr(const char source[], OopType symbolList);

  EXTERN_GCI_DEC(OopType) 
GciExecuteStr_(const char source[], OopType symbolList, ushort environmentId );

  EXTERN_GCI_DEC(OopType) 
GciExecuteStrDbg( const char source[], OopType symbolList, int flags);

  EXTERN_GCI_DEC(OopType) 
GciExecuteStrDbg_(const char source[], OopType symbolList, int flags , ushort environmentId);

/* =============================================================================
 * GciExecuteStrFromContext, GciExecuteStrFromContext_ functions
 *   Execute a Smalltalk expression contained in a C string as if it were a
 *   message sent to an object.
 *
 * Input Arguments:
 *   source	A null-terminated string containing a sequence of one or more
 *              statements to be executed.
 *   contextObject
 *		The OOP of any GemStone object.  The code to be executed is
 *              compiled as if it were an instance method in the class of
 *              contextObject.
 *              A value of OOP_NO_CONTEXT means no context.
 *   symbolList	The OOP of a GemStone symbol list (that is, an Array of
 *              instances of SymbolDictionary).  The compiler uses the
 *              symbolList to resolve symbolic references in the code in source.
 *              A value of OOP_NIL means to use the default symbol list for the
 *              current GemStone session (that is, System myUserProfile
 *              symbolList).
 *
 *   environmentId specifies a compilation environment for the execution
 *
 * Return Value:
 *   Returns the OOP of the execution result.  In case of error, this function
 *   returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciExecuteStrFromContext(const char source[], OopType contextObject, OopType symbolList );

  EXTERN_GCI_DEC(OopType) 
GciExecuteStrFromContext_(const char source[], OopType contextObject,
                    OopType symbolList , ushort environmentId );

/* =============================================================================
 * GciExecuteStrFromContextDbg_ function
 *
 *  source       A C string containing a sequence of one or more statements .
 *               8 bit ascii unless sourceClass==OOP_CLASS_Utf8 in which case
 *               This must be a UTF-8 encoded string.
 *               
 *  sourceSize   the number of bytes in the 'source' array, usually strlen(source)
 *
 *  sourceClass  The OOP of the class that 'source' should be converted to. 
 *                Examples are OOP_CLASS_STRING, OOP_CLASS_Utf8, OOP_CLASS_Unicode7 .
 *   contextObject
 *              The OOP of any GemStone object.  The code to be executed is
 *              compiled as if it were an instance method in the class of
 *              contextObject.
 *              A value of OOP_NO_CONTEXT means no context.
 *
 *   symbolList The OOP of a GemStone symbol list (that is, an Array of
 *              instances of SymbolDictionary).  The compiler uses the
 *              symbolList to resolve symbolic references in the code in source.
 *              A value of OOP_NIL means to use the default symbol list for the
 *              current GemStone session (that is, System myUserProfile
 *              symbolList).
 *
 *   flags      zero, or one of bits per GCI_PERFORM_FLAG* in gcicmn.ht
 *
 *   environmentId specifies a compilation environment for the execution,
 *                 normally zero
 *
 * Return Value:
 *   Returns the OOP of the execution result.  In case of error, this function
 *   returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciExecuteStrFromContextDbg(
  const char source[], int64 sourceSize, OopType sourceClass,
  OopType contextObject, OopType symbolList, int flags);

  EXTERN_GCI_DEC(OopType) 
GciExecuteStrFromContextDbg_(
  const char source[], int64 sourceSize, OopType sourceClass,
  OopType contextObject, OopType symbolList,
  int flags,  ushort environmentId );

/* =============================================================================
 * GciExecuteStrFetchBytes
 *
 * Executes source and assumming the execution result is a byte format object,
 * returns that String in *result .
 *
 * Function result is the number of bytes returned in *result, 
 * or -1  if an error is available to be fetche with GciErr .
 *
 *  source       The string to be executed.
 *  sourceSize   the number of bytes in the 'source' array, usually strlen(source).
 *               if sourceSize == -1,  strlen(source) is used.
 *
 *  sourceClass  The OOP of the class that 'source' should be converted to.
 *                Examples are OOP_CLASS_STRING, OOP_CLASS_Utf8, OOP_CLASS_Unicode7 .
 *   contextObject
 *              The OOP of any GemStone object.  The code to be executed is
 *              compiled as if it were an instance method in the class of
 *              contextObject.
 *              A value of OOP_NO_CONTEXT means no context.
 *
 *   symbolList The OOP of a GemStone symbol list (that is, an Array of
 *              instances of SymbolDictionary).  The compiler uses the
 *              symbolList to resolve symbolic references in the code in source.
 *              A value of OOP_NIL means to use the default symbol list for the
 *              current GemStone session (that is, System myUserProfile
 *              symbolList).
 *
 *  Execution is in environment 0 using GCI_PERFORM_FLAG_ENABLE_DEBUG .
 *==============================================================================
 */
  EXTERN_GCI_DEC(int64)
GciExecuteStrFetchBytes( const char* source, int64 sourceSize,
                OopType sourceClass, OopType contextObject,
               OopType symbolList, ByteType *result, int64 maxResultSize);


/* =============================================================================
 * GciFetchByte function
 *   Fetch one byte from an indexed byte object.
 *
 * Input Arguments:
 *   theObject	The OOP of the GemStone byte object.
 *   atIndex	The index into theObject of the element to be fetched.  The
 *              index of the first element is 1.
 *
 * Return Value:
 *   Returns the byte value at the specified index.  In case of error, this
 *   function returns zero.
 *==============================================================================
 */
  EXTERN_GCI_DEC(ByteType) 
GciFetchByte(OopType theObject, int64 atIndex);

/* =============================================================================
 * GciFetchBytes function
 *   Fetch multiple bytes from an indexed byte object.
 *
 * Input Arguments:
 *   theObject	The OOP of the GemStone byte object.
 *   startIndex	The index into theObject at which to begin fetching bytes.  (The
 *              index of the first element is 1.)  Note that if startIndex is 1
 *              greater than the size of the object, this function returns a
 *              byte array of size 0, but no error is generated.
 *   numBytes	The maximum number of bytes to return.
 *
 * Result Arguments:
 *   theBytes	The array of fetched bytes.
 *
 * Return Value:
 *   Returns the number of bytes fetched.  (This may be less than numBytes,
 *   depending upon the size of theObject.)  In case of error, this function
 *   returns zero.
 *
 * Gs64 v3.0:
 * If theObject is an object with multiple bytes per character or digit
 *  such as DoubleByteString, LargeInteger, Float ,
 * the startIndex and numBytes must be aligned on a character boundary
 * and the result in theBytes will have been swizzled to client native
 * byte order if needed.
 *==============================================================================
 */
  EXTERN_GCI_DEC(int64) 
GciFetchBytes_(
  OopType theObject, int64 startIndex,
  ByteType theBytes[], int64 numBytes 
    );

/* =======================================================================
 * GciFetchUtf8Bytes_
 *  aString must be a kind of String, MultiByteString or Utf8
 *  If aString is an instance of Utf8 , or a kind of String with
 *  all codePoints <= 127, *utf8String will be unchanged and behavior
 *  is the same as GciFetchBytes_ .  Note that the result buffer
 *  contains bytes and may not start or end at codePoint boundaries
 *  within an instance of Utf8 .
 *
 *  If aString is a kind of String or MultiByteString with codePoints
 *  above 127,  and startIndex == 1 then
 *  aString is sent encodeAsUTF8 and the result added to the export
 *  set and returned in *utf8String. 
 *  Then bytes are fetched from *utf8String are returned in *buf, up to
 *  a maximum of bufSize.  0 is returned if there was an error .
 *  The caller should pass *utf8String to GciReleaseOops
 *  after fetching all the bytes desired.
 *
 *  flags  0 = normal fetch , 1 = substitute '.' for illegal codePoints 
 *         2 = generated description in *buf instead of signalling error
 *  which would prevent conversion to Utf8 instead of generating an Error.
 */ 
  EXTERN_GCI_DEC(int64) 
GciFetchUtf8Bytes_(
  OopType aString, int64 startIndex,
  ByteType *buf, int64 bufSize, OopType *utf8String, int flags );


/*=======================================================================
 * GciFetchChars
 *  equivalent to GciFetchBytes, except that it is assummed that theObject
 *  contains ASCII text. The bytes fetched are stored in memory
 *  starting at cString.  At most maxSize - 1 bytes will be fetched from
 *  the object, and a \0 character will be stored in memory following
 *  the bytes fetched.  The function returns the number of bytes fetched,
 *  excluding the null terminator character, which is equvalent to
 *  strlen(cString) if the object does not contain any null characters.
 *  If an error occurs, the function result is 0, and the contents of
 *  *cString is undefined.
 *=======================================================================
 */
  EXTERN_GCI_DEC(int64) 
GciFetchChars_(
  OopType theObject, int64 startIndex,
  char *cString, int64 maxSize 
    );

/* =============================================================================
 * GciFetchClass function
 *   Fetch the class of an object.
 *
 * Input Arguments:
 *   theObject	The OOP of the specified object.
 *
 * Return Value:
 *   Returns the OOP of the object's class.  In case of error, this function
 *   returns OOP_NIL.  The GCI include file gcioop.ht defines a C constant for
 *   each of the Smalltalk kernel classes.
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(OopType) 
GciFetchClass(OopType theObject);

/* =============================================================================
 * GciFetchVaryingOop function
 *   Fetch the OOP of one unnamed instance variable from an indexed pointer
 *   object or NSC.
 *
 * Input Arguments:
 *   theObject	The OOP of the pointer object or NSC.
 *   atIndex	The index of the OOP to be fetched.  The index of the first
 *              unnamed instance variable's OOP is 1.
 *
 * Return Value:
 *   Returns the OOP of the unnamed instance variable at index atIndex.  In case
 *   of error, this function returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciFetchVaryingOop(OopType theObject, int64 atIndex);

/* =============================================================================
 * GciFetchVaryingOops function
 *   Fetch the OOPs of one or more unnamed instance variables from an indexed
 *   pointer object or NSC.
 *
 * Input Arguments:
 *   theObject	The OOP of the pointer object or NSC.
 *   startIndex	The index of the first OOP to be fetched.  The index of the
 *              first unnamed instance variable's OOP is 1.  Note that if
 *              startIndex is 1 greater than the number of theObject's unnamed
 *              instance variables, this function returns an array of size 0,
 *              but no error is generated.
 *   numOops	Maximum number of elements to return.
 *
 * Result Arguments:
 *   theOops	The array of fetched OOPs.
 *
 * Return Value:
 *   Returns the number of OOPs fetched.  (This may be less than numOops,
 *   depending upon the size of theObject.)  In case of error, this function
 *   returns zero.
 *==============================================================================
 */
  EXTERN_GCI_DEC(int) 
GciFetchVaryingOops(
  OopType theObject, int64 startIndex,
  OopType theOops[], int numOops
    );

/* =============================================================================
 * GciFetchVaryingSize function
 *   Fetch the number of unnamed instance variables in a pointer object or NSC.
 *
 * Input Arguments:
 *   theObject	The OOP of the specified object.
 *
 * Return Value:
 *   Returns the number of unnamed instance variables in theObject.  In case of
 *   error, this function returns zero.
 *==============================================================================
 */
  EXTERN_GCI_DEC(int64) 
GciFetchVaryingSize_(OopType theObject);

/*=======================================================================
 * GciFetchNameOfClass
 *   Returns the object identifier of the String object that is
 *   the name of aClass.  aClass must be an instance of Class.  This
 *  function does not allow MetaClasses as the argument, since
 *  MetaClasses are instances of Behavior and do not have a "name"
 *  instance variable.  To obtain the name of MetaClasses, send the
 *  message "name" to the class.
 *=======================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciFetchNameOfClass(OopType aClass);

/* =============================================================================
 * GciFetchNamedOop function
 *   Fetch the OOP of one of an object's named instance variables.
 *
 * Input Arguments:
 *   theObject	The OOP of the GemStone object.
 *   atIndex	The index into theObject's named instance variables of the
 *              element to be fetched.  The index of the first named instance
 *              variable is 1.
 *
 * Return Value:
 *   Returns the OOP of the specified named instance variable.  In case of
 *   error, this function returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciFetchNamedOop(OopType theObject, int atIndex);

/* =============================================================================
 * GciFetchNamedOops function
 *   Fetch the OOPs of one or more of an object's named instance variables.
 *
 * Input Arguments:
 *   theObject	The OOP of the source GemStone object.
 *   startIndex	The index into theObject's named instance variables at which to
 *              begin fetching.  (The index of the first named instance variable
 *              is 1.)  Note that if startIndex is 1 greater than the number of
 *              the object's named instance variables, this function returns an
 *              array of size 0, but no error is generated.
 *   numOops	The maximum number of elements to return.
 *
 * Result Arguments:
 *   theOops	The array of fetched OOPs.
 *
 * Return Value:
 *   Returns the number of OOPs fetched.  (This may be less than numOops,
 *   depending upon the size of theObject.)  In case of error, this function
 *   returns zero.
 *==============================================================================
 */
  EXTERN_GCI_DEC(int) 
GciFetchNamedOops(
  OopType theObject, int startIndex,
  OopType theOops[], int numOops
    );

/* =============================================================================
 * GciFetchNamedSize function
 *   Fetch the number of named instance variables in an object.
 *
 * Input Arguments:
 *   theObject	The OOP of the specified object.
 *
 * Return Value:
 *   Returns the number of named instance variables in theObject.  In case of
 *   error, this function returns zero.
 *==============================================================================
 */
  EXTERN_GCI_DEC(int) 
GciFetchNamedSize(OopType theObject);

/*=======================================================================
 * GciFetchObjInfo
 *  fetches information and values from an object.
 *
 *  Deprecated.  New code should use GciFetchObjectInfo .
 *
 * arguments
 *   theObject - oop of any object with byte, pointer, or Nsc format.
 *   startIndex - offset in object at which to start fetching, using
 *                GciFetchOops or GciFetchBytes semantics.
 *               startIndex is ignored if bufSize == 0 or buffer == NULL . 
 *
 *   bufSize   - the size in BYTES of the buffer, maximum number
 *                 of elements fetched for a byte object, bufSize/8
 *	           will be max elements fetched for an oop object.
 *
 *   info      - pointer to an instance of GciObjInfoSType, may be NULL
 *   buffer    - pointer to an area where byte or oop values will be returned,
 *                 may be NULL, must be aligned on 8 byte boundary on RISC machines.
 *   numReturned - number of logical elements (bytes or oops) returned in
 *                 buffer.  Remember sizeof(OopType) is 8 .
 *   If either info or buffer is NULL, then that portion of the result is
 *    not filled in. If numReturned is NULL, then buffer will not be filled in.
 *
 *  function Result:
 *     TRUE if fetch was successful, FALSE if an error occurred.
 *
 * Gs64 v3.0:
 * If theObject is an object with multiple bytes per character or digit
 * such as DoubleByteString, LargeInteger, Float ,
 * the startIndex and bufSize must be aligned on a character boundary
 * and the result in buffer will have been swizzled to client native
 * byte order if needed.
 *=======================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciFetchObjInfo(
  OopType theObject,
  int64 startIndex, int64 bufSize,
  GciObjInfoSType *info, ByteType *buffer,
  int64 *numReturned
    );

/*=======================================================================
 * GciFetchObjectInfo
 *  fetches information and values from an object.
 *
 * arguments
 *   theObject - oop of any object with byte, pointer, or Nsc format.
 *   *args - an instance of GciFetchObjInfoArgsSType
 *
 *   args->startIndex - offset in object at which to start fetching, using
 *               GciFetchOops or GciFetchBytes semantics.
 *               startIndex is ignored if bufSize == 0 or buffer == NULL . 
 *
 *   args->bufSize   - the size in BYTES of the buffer, maximum number
 *               of elements fetched for a byte object, bufSize/8
 *	         will be max elements fetched for an oop object.
 *               If greater than zero, and if a Float or BinaryFloat is
 *               being fetched, it must be large enough to fetch the complete
 *               object.
 *               
 *   args->info  - pointer to an instance of GciObjInfoSType, may be NULL
 *   args->buffer - pointer to an area where byte or oop values will be 
 *                 returned, may be NULL
 *   args->numReturned - number of logical elements (bytes or oops) returned in
 *                 buffer.  Remember sizeof(OopType) is 8 .
 *   If either info or buffer is NULL, then that portion of the result is
 *    not filled in. 
 *
 *   args->retrievalFlags 
 *              If (args->retrievalFlags & GCI_RETRIEVE_EXPORT) != 0
 *              then if theObject is non-special , theObject will automatically
 *              be added to an export set using GciSaveObjs semantics .
 *              theObject is added to the user action's export set if 
 *              GciFetchObjectInfo is called from within a user action, 
 *              otherwise it is added to the session's  PureExportSet  .
 *
 *   args->isRpc    ignored; for internal use by implementation of GCI.
 *
 *  function Result:
 *     TRUE if fetch was successful, FALSE if an error occurred.
 *
 * Gs64 v3.0:
 * If theObject is an object with multiple bytes per character or digit
 * such as DoubleByteString, LargeInteger, Float ,
 * the args->startIndex and args->bufSize must be aligned on a character boundary
 * and the result in args->buffer will have been swizzled to client native
 * byte order if needed.
 *=======================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciFetchObjectInfo(OopType theObject, GciFetchObjInfoArgsSType *args);


/* =============================================================================
 * GciFetchObjImpl function
 *   Fetch the implementation of an object.
 *
 * Input Arguments:
 *   theObject	The OOP of the specified object.
 *
 * Return Value:
 *   Returns an integer representing the implementation type of theObject
 *   (0=pointer, 1=byte, 2=NSC, or 3=special).  In case of error, the return
 *   value is undefined.
 *==============================================================================
 */
  EXTERN_GCI_DEC(int) 
GciFetchObjImpl(OopType theObject);

/* =============================================================================
 * GciFetchOop function
 *   Fetch the OOP of one instance variable of an object.
 *
 * Input Arguments:
 *   theObject	The OOP of the source object.
 *   atIndex	The index into theObject of the OOP to be fetched. The index of
 *              the first OOP is 1.
 *
 * Return Value:
 *   Returns the OOP at the specified index of the source object.  In case of
 *   error, this function returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciFetchOop(OopType theObject, int64 atIndex);

/* =============================================================================
 * GciFetchOops function
 *   Fetch the OOPs of one or more instance variables of an object.
 *
 * Input Arguments:
 *   theObject	The OOP of the source object.
 *   startIndex	The index into theObject at which to begin fetching OOPs.  The
 *              index of the first OOP is 1.  If startIndex is 1 greater than
 *              the size of the object, this function returns an array of size
 *              0, but no error is generated.
 *   numOops	The maximum number of OOPs to return.
 *
 * Result Arguments:
 *   theOops	The array of fetched OOPs.
 *
 * Return Value:
 *   Returns the number of OOPs fetched.  (This may be less than numOops,
 *   depending upon the size of theObject.)  In case of error, this function
 *   returns zero.
 *==============================================================================
 */
  EXTERN_GCI_DEC(int) 
GciFetchOops(
  OopType theObject, int64 startIndex,
  OopType theOops[], int numOops 
    );

/* =============================================================================
 * GciFetchPaths function
 *   Fetch selected multiple OOPs from an object tree.
 *
 * Input Arguments:
 *   theOops	A collection of OOPs from which you want to fetch.
 *   numOops	The size of theOops.
 *   paths	An array of integers.  This one-dimensional array contains the
 *              elements of all constituent paths, laid end to end.
 *   pathSizes	An array of integers.  Each element of this array is the length
 *              of the corresponding path in the paths array (that is, the
 *              number of elements in each constituent path).
 *   numPaths	The number of paths in the paths array.  This should be the same
 *              as the number of integers in the pathSizes array.
 *
 * Result Arguments:
 *   results	An array containing the OOPs that were fetched.
 *
 * Return Value:
 *   Returns TRUE if all desired objects were successfully fetched.  Returns
 *   FALSE if the fetch on any path fails for any reason.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciFetchPaths(
  const OopType theOops[], int numOops,
  const int paths[], const int pathSizes[],
  int numPaths,
  OopType results[] 
    );

/* =============================================================================
 * GciFetchSize function
 *   Fetch the size of an object.
 *
 * Input Arguments:
 *   theObject	The OOP of the specified object.
 *
 * Return Value:
 *   Returns the size of theObject.  In case of error, this function returns
 *   zero.
 *==============================================================================
 */
  EXTERN_GCI_DEC(int64) 
GciFetchSize_(OopType theObject);

/* =============================================================================
 * GciFindObjRep function
 *   Fetch an object report in a traversal buffer.
 *
 * Input Arguments:
 *   travBuff	A traversal buffer returned by a call to GciTraverseObjs.
 *   theObject	The OOP of the object to find.
 *
 * Return Value:
 *   Returns a pointer to an object report within the traversal buffer.  In case
 *   of error, this function returns NULL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(GciObjRepHdrSType*) 
GciFindObjRep(GciTravBufType* buf, OopType theObject);

/*========================================================================
 *  GciFloatKind
 *
 *   returns the kind of float which the argument represents.
 *========================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(GciFloatKindEType) 
GciFloatKind(double aReal);

/* =============================================================================
 * GciFltToOop function
 *   Convert a C double value to a Float object.
 *
 * Input Arguments:
 *   aReal	The floating point value to be translated into an object.
 *
 * Return Value:
 *   Returns the OOP of the GemStone SmallDouble or Float object 
 *   that corresponds to the C value.  
 *   In case of error, this function returns OOP_NIL.
 *
   An IEEE 64 bit binary float (a C double) contains the bits
    seeeeeee|eeeeffff|ffffffff|ffffffff|ffffffff|ffffffff|ffffffff|ffffffff
   where bits are shown with least-significant on the right, 
     's' is the sign bit.
     each 'e' is a bit of the exponent
     each 'f' is a bit of the mantissa.

    If (e > 0) the double has value (-1 * s) * 2^^(e-0x3ff) * 1.f  .
    If (e == 0) and f != 0 ,
      the double has value (-1 * s) * 2^^(e-0x3fe) * 0.f  (i.e. subnormal) .
    zero is represented as s==0, e==0, f==0  . See Sparc V9 Arch Manual pg 28.
 
   An OopType which is an instance of SmallDouble contains these bits:
    eeeeeeee|ffffffff|ffffffff|ffffffff|ffffffff|ffffffff|ffffffff|ffffs110
   which is the same number of bits of mantissa as a C double, but
     only 8 bits of exponent as compared to 11 bits of exponent in C double.
   If the C double has value zero , the SmallDouble has bits e,f,s all zero.
    otherwise the SmallDouble has non-zero exponent, and
      the value is (-1 * s) * 2^^(e - 0x7f ) * 1.f
   There are no subnormal or NaN SmallDouble's . C doubles which are NaN
    or subnormal must be converted to instances of Float .
   There are no subnormal or NaN SmallDouble's .
   Thus SmallDouble's can represent  C double that have value zero
   or that have exponent bits in range 0x381 to 0x3ff,
    which corresponds to about 5.0e-39 to 6.0e+38 , which
    is also the range of  C 4-byte float  .
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciFltToOop(double aReal);

/*========================================================================
 * GciGetFreeOop,  GciGetFreeOops
 *
 *  Allocates object identifiers without creating objects.
 *
 *  An object identifer returned from either of these functions
 *  remains allocated to the Gci session until the session either calls
 *  GciLogout, or the identifier is used as the objId argument to a
 *  GciCreate*() call.  Identifers returned by GciGetFreeOop* may ONLY
 *  be used as the objId argument to a GciCreate call, or stored as a
 *  value in a GciStore*Oop call. (see GCI manual page for a complete list of
 *   applicable store functions) .
 *
 *  If an object identifer returned from GciGetFreeOop(s) is used as a value
 *  in a GciStore call before it is used as the objId argument of a GciCreate
 *  call, then an "unresolved foward reference" is created in object memory.
 *  This is a reference to an object that doesn't exist yet.  This
 *  forward reference must be satisfied by using the identifier as the objId
 *  argument to a GciCreate call before a GciCommit can be successfully
 *  executed.  However, it is illegal to create a forward reference to a Symbol.
 *
 *  If GciCommit is attempted prior to satisfying all of the
 *  unresolved forward references, an error will be generated and GciCommit
 *  will return false.  In this case, GciCreate can be used to satisfy the
 *  forward references and GciCommit can be reattempted.
 *
 *  GciAbort will remove all unsatified forward references from the session's
 *  object space, just as it removes any other uncommitted modifications.
 *
 *========================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciGetFreeOop(void);

  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciGetFreeOops(int count, OopType *resultOops);

/*========================================================================
 * GciGetFreeOopsEncoded
 *
 *  Same as GciGetFreeOops except that oops are returned in an encoded 
 *  array that is more compact for less network I/O.  The encoded array
 *  must be decoded by calling GciDecodeOopArray() before the oops can 
 *  be used.  
 *
 *  Arguments:
 *    count (IN/OUT)       - IN: total number of oops to requested
 *                         - OUT: number of oops returned in the encoded 
 *                           oop array.
 *    encodedOops (IN/OUT) - ptr to memory for holding encoded oops.  
 *                           Must be large enough to hold at least the
 *                           input value of "count".
 *========================================================================
 */
  EXTERN_GCI_DEC(void)
GciGetFreeOopsEncoded(int *count, OopType *encodedOops);


/* =============================================================================
 * GciGetSessionId function
 *   Find the ID number of the current user session.
 *
 * Return Value:
 *   Returns the session ID currently being used for communication with
 *   GemStone.  Returns GCI_INVALID_SESSION_ID if there is no session ID (that
 *   is, if the application is not logged in).
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(GciSessionIdType) 
GciGetSessionId(void);

/* =============================================================================
 * GciGetMaxSessionId returns the maximum session id allowed at the time
 * this call is made. As more and more sessions are created this value
 * can increase.
 *==============================================================================
 */
  EXTERN_GCI_DEC(GciSessionIdType) 
GciGetMaxSessionId(void);

/* ==========================================================================
 *  GciHandleError
 *
 * GciHandleError is NOT IMPLEMENTED in this release 
 *
 * Old comments:
 *      arguments: errorReport, address of a Gci error report structure
 *
 *	results:  function returns a boolean, TRUE indicates an error occurred,
 *	   in which case errorReport contains the latest error information,
 *	   FALSE indicates no error occurred, and contents of errorReport is
 *	   undefined..
 *
 *      This function MUST BE CALLED INSTEAD OF GciErr IF GciPushErrHandler
 *      has been used to register a jump buffer
 * ==========================================================================
 */
/*  EXTERN_GCI_DEC(BoolType) 
 * GciHandleError(GciErrSType *errorReport);
 */

/* ==========================================================================
 * GciHardBreak
 * 
 *  Depending on the operation in progress, hard break may kill
 *  the session, or may just interrupt the current Smalltalk execution. 
 *  A hard break during Smalltalk execution differs from a soft break
 *  in that hard break is not trappable by Smalltalk Exceptions.  Hard
 *  break is also recognized by some long primitives that do not respond to
 *  soft break.
 *
 *  A hard break during the following Repository methods will kill the session
 *    markForCollection, fullBackupTo:,  restoreFromBackup(s): 
 *    objectAudit, auditWithLimit:, repairWithLimit:
 *    pagesWithPercentFree   .
 *  
 *  Gs64 v3.2 , has no effect if called from within a user action.
 *
 * ==========================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciHardBreak(void);

/* ==========================================================================
 * GciHiddenSetIncludesOop
 * 
 * Returns TRUE if the given hidden set id is valid, the object is not 
 * a special, and the hidden set contains the oop.  Returns FALSE otherwise.
 * Hidden set ids are version dependant and are defined in the method
 * System>>HiddenSetSpecifiers.
 * ==========================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciHiddenSetIncludesOop(OopType theOop, int hiddenSetId);

/* =============================================================================
 * GciInit function
 *   Initialize the GemStone C Interface.
 *
 * Return Value:
 *   The function GciInit returns TRUE or FALSE to indicate successful or
 *   unsuccessful initialization of the GCI interface.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciInit(void);

// GciInit_ moved to gcisup.hf

/* ==========================================================================
 *  GciInitAppName
 *
 *  Provides a way to override the default executable configuration
 *  file name for linkable GCI applications.  The default is "gci.conf"
 *  For example, if called as
 *     GciInitAppName("mytool", TRUE);
 *  then the executable configuration file name will be "mytool.conf" .
 *
 *  The logWarnings option, if TRUE, enables printing of warning messages
 *  about problems parsing the configuration file to stdout.
 *
 *  If used, GciInitAppName must be called before GciInit is called.
 *
 * GciInitAppName_ variant :
 *
 *  If gemTempObjCacheOverrideKB is > 0 , the value will override any
 *  GEM_TEMPOBJ_CACHE_SIZE settings in config files, when GciInit()
 *  reads the config files in a Linked application or gem process .
 *  gemTempObjCacheOverrideKB is ignored in RPC Gci library .
 *
 *  If gemNativeCodeOverride >= 0, value overrides
 *  GEM_NATIVE_CODE_ENABLED value from config file 
 *  in Linked application or gem process .
 *
 *  Only one of GciInitAppName or GciInitAppName_ should be called.
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciInitAppName(const char *applicationName, BoolType logWarnings);

  EXTERN_GCI_DEC(void) 
GciInitAppName_(const char *applicationName, BoolType logWarnings,
		uint gemTempObjCacheOverrideKB, int gemNativeCodeOverride);

/* ==========================================================================
 * GciSetCacheName
 *
 * Sets the name that a linked application will be know by in the shared cache.
 * The argument will become the processName reported by System|cacheStatistics.
 *
 * If GciIsRemote() returns TRUE, this function does nothing and always
 *  returns TRUE;
 * 
 * If GciIsRemote() returns FALSE, then this function:
 *   must be called after GciInit and the argument will take effect
 *   in the shared cache after the next GciLogin ;
 *   returns TRUE if called after GciInit, FALSE otherwise .
 * 
 * ==========================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(BoolType)
GciSetCacheName_(const char* name);

/* =============================================================================
 * GciInstMethodForClass function
 *   Compile an instance method for a class.
 *
 * Input Arguments:
 *   source	The OOP of a Smalltalk string to be compiled as an instance
 *              method. May be an kind of String or MultiByteString, or
 *              an kind of Utf8. If a kind of Utf8, the resulting sourceString
 *              will be an instance of Unicode7, Unicode16 or Unicode32.
 * 
 *   oclass	The OOP of the class with which the method is to be associated.
 *   category	The OOP of a Smalltalk string which contains the name of the
 *              category to which the method is added.  If the category is nil
 *              (OOP_NIL), the compiler will add this method to the category "as
 *              yet unclassified".
 *   symbolList	The OOP of a GemStone symbol list (that is, an Array of
 *              instances of SymbolDictionary).  Smalltalk resolves symbolic
 *              references in source code using symbols that are available from
 *              symbolList.  A value of OOP_NIL means to use the default symbol
 *              list for the current GemStone session (that is,
 *              System myUserProfile symbolList).
 *
 *   If compilation errors occur, an error is generated.
 *
 *   Function result: OOP_NIL, or oop of a String containing warning messages
 *
 *   If a SessionMethodsDict has been installed (via 
 *     GsCurrentSession>>_installSessionMethodDict:), the compiler is invoked
 *     by calling Behavior>>compileMethod:dictionaries:category:, in which case
 *     no warnings are generated.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciInstMethodForClass(OopType source, OopType oclass, OopType category,
   OopType symbolList);

/* =============================================================================
 * GciCompileMethod
 *
 *  replacement for GciInstMethodForClass and GciClassMethodForClass.
 * 
 * Input Arguments:
 *   source     The OOP of a Smalltalk string to be compiled as an instance
 *              method. May be an kind of String or MultiByteString, or
 *              an kind of Utf8. If a kind of Utf8, the resulting sourceString
 *              will be an instance of Unicode7, Unicode16 or Unicode32.
 *
 *   oclass     The OOP of the class with which the method is to be associated.
 *   category   The OOP of a Smalltalk string which contains the name of the
 *              category to which the method is added.  If the category is nil
 *              (OOP_NIL), the compiler will add this method to the category "as
 *              yet unclassified".
 *   symbolList The OOP of a GemStone symbol list (that is, an Array of
 *              instances of SymbolDictionary).  Smalltalk resolves symbolic
 *              references in source code using symbols that are available from
 *              symbolList.  A value of OOP_NIL means to use the default symbol
 *              list for the current GemStone session (that is,
 *              System myUserProfile symbolList).
 *
 *   If compilation errors occur, an error is generated.
 *
 *  overrideSelector  if not OOP_NIL, then it is OOP of a String which is
 *      converted to a Symbol and used in precedence to the selector pattern
 *      in the method source when installing the method in the method dictionary.
 *      Sending 'selector' to the resulting method will also reflect the
 *      overrideSelector argument. 
 *      Values other than OOP_NIL are intended for bootstrapping Ruby image only.
 *
 *  compileFlags  zero or bits per GCI_COMPILE* in gcicmn.ht  .
 *                If bit GCI_COMPILE_CLASS_METH is one, compiles a class method,
 *                otherwise compiles an instance method.
 *
 *  Function result: OOP_NIL, or oop of a String containing warning messages
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciCompileMethod(OopType source, OopType oclass, OopType category,
     OopType symbolList, OopType overrideSelector,
     int compileFlags, ushort environmentId);

/* =============================================================================
 * GciIsKindOf function
 *   Determine whether or not an object is some kind of a given class or class
 *   history.
 *
 * Input Arguments:
 *   anObj	    The object whose kind is to be checked.
 *
 *   aClassHistory  A class or class history to compare with the object's kind.
 *                  If a class is given, then the class history of that class
 *	            is used.
 *
 * Return Value:
 *   GciIsKindOf returns TRUE when the class of anObj is identical to or is
 *   a subclass of any class in aClassHistory.  It returns 
 *   FALSE otherwise.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciIsKindOf(OopType anObj, OopType aClassHistory);

/* =============================================================================
 * GciIsKindOfClass function
 *   Determine whether or not an object is some kind of a given class.
 *
 * Input Arguments:
 *   anObj	The object whose kind is to be checked.
 *   aClass	A class to compare with the object's kind.
 *
 * Return Value:
 *   GciIsKindOfClass returns TRUE if the class of anObj is identical to, or
 *   a subclass of aClass .  It returns FALSE otherwise.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciIsKindOfClass(OopType anObj, OopType aClass);

/* =============================================================================
 * GciIsSubclassOf function
 *   Determine whether or not a class is a subclass of a given class or class
 *   history.
 *
 * Input Arguments:
 *   aClass	     The class that is to be checked.
 *
 *   aClassHistory   A class or class history to compare with the first class.
 *                   If a class is given, the class history of that class is 
 *                   used.
 *
 * Return Value:
 *   GciIsSubclassOf returns TRUE if aClass is identical to, or a subclass of 
 *   any class in aClassHistory.  Returns FALSE otherwise.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciIsSubclassOf(OopType aClass, OopType aClassHistory);

/* =============================================================================
 * GciIsSubclassOfClass function
 *   Determine whether or not a class is a subclass of a given class.
 *
 * Input Arguments:
 *   aClass	  The class that is to be checked.
 *   superClass	  A class to compare with the first class.
 *
 * Return Value:
 *   GciIsSubclassOf returns TRUE if aClass is identical to or is a subclass 
 *   of superClass .  It returns FALSE otherwise.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciIsSubclassOfClass(OopType aClass, OopType superClass);

/* =============================================================================
 * GciIsRemote function
 *   Determine whether the application is running linked or remotely.
 *
 * Return Value:
 *   Returns TRUE if this application is linked with GciRpc (the remote
 *   procedure call version of the GCI).  Returns FALSE if this application is
 *   linked with GciLnk (that is, if the GCI is linked with your GemStone
 *   session).
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(BoolType) 
GciIsRemote(void);

/* =============================================================================
 * GciSessionIsRemote function
 *   Determine whether or not the current session is using a Gem on another
 *   machine.
 *
 * Return Value:
 *   GciSessionIsRemote returns TRUE if the current GCI session is
 *   connected to a remote Gem.  Returns FALSE if the current GCI session is
 *   connected to a linked Gem.
 *
 *   GciSessionIsRemote raises an error if the current session is invalid.
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(BoolType) 
GciSessionIsRemote(void);

/* =============================================================================
 * GciIvNameToIdx function
 *   Fetch the index of an instance variable name.
 *
 * Input Arguments:
 *   oclass		The OOP of the class from which to obtain information
 *			about instance variables.
 *   instVarName	The instance variable name to search for.
 *
 * Return Value:
 *   Returns the index of instVarName into the array of named instance variables
 *   for the specified class.  Returns 0 if the name is not found or if an error
 *   is encountered.
 *==============================================================================
 */
  EXTERN_GCI_DEC(int) 
GciIvNameToIdx(OopType oclass, const char instVarName[]);

/* =============================================================================
 * GciLogin function
 *   Start a user session.
 *
 * Input Arguments:
 *   gemstoneUsername	The user's GemStone user name (a null-terminated
 *                      string).
 *   gemstonePassword	The user's GemStone password (a null-terminated string).
 *
 *  Function result is TRUE if GciLogin is successful.
 *  function result is FALSE if GciErr() should be called to get the
 *  error or warning message.
 *  If the result is FALSE and GciGetSessionId() returns a valid session
 *  then the message is a warning. The login will have completed ok.
 *  The only warning currently defined is RT_ERR_WARNING_PASSWD_EXPIRE.
 * =======================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciLogin(const char gemstoneUsername[], const char gemstonePassword[]);

/* =============================================================================
 * GciLogout function
 *   End the current user session.
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciLogout(void);

/* =============================================================================
 * GciI64ToOop function
 *   Return a GemStone object that corresponds to a C 64 bit integer.
 *
 * Input Arguments:
 *   arg  a   C 64 bit signed integer 
 *
 * Return Value:
 *   The GciI64ToOop function returns the OOP of a GemStone object whose value
 *   is equivalent to the input.
 *  
 * If the result is not a SmallInteger, the result is automatically
 *  saved by a GciSaveObjs() call. (see also GciSaveObjs ).
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType)
GciI64ToOop(int64 arg);

  EXTERN_GCI_DEC(OopType)
GciI32ToOop(int arg);

#if defined(FLG_AIX_UNIX) && !defined(_LP64)
     /* 32bit AIX libgci*/
#define GCI_I32_TO_OOP(arg) GciI64ToOop(arg)
#else
  // GCI_I32_TO_OOP defined in gcioop.ht
#endif

/* ===========================================================================
 *  Gci_doubleToSmallDouble
 *
 *  If the argument is representable as a SmallDouble , return the oop
 *  representing that value , otherwise return OOP_ILLEGAL.
 *  See comments for GciFltToOop() for more details of SmallDouble 
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType)
Gci_doubleToSmallDouble(double aFloat);

/* =============================================================================
 * GciPointerToByteArray function
 *
 * Input Arguments: a C pointer
 *
 * Return Value
 *   A GemStone SmallInteger or ByteArray containing the value of the pointer.
 *   The result will have machine dependent byte order and is not
 *   intended to be committed.  
 *   If the argument is a 64 bit pointer aligned on an 8 byte boundary,
 *   or is a 32 bit pointer , the result will be a  SmallInteger ,
 *   otherwise the result will be a ByteArray .
 *=============================================================================
 */
  EXTERN_GCI_DEC(OopType)
GciPointerToByteArray(void *p);

/*=============================================================================
 * GciByteArrayToPointer
 * 
 * Given an argument that was a result from GciPointerToByteArray,
 * return the corresponding C pointer .
 * ============================================================================
 */
  EXTERN_GCI_DEC(void *)
GciByteArrayToPointer(OopType arg);

/* =============================================================================
 * GciMoreTraversal function
 *   Continue object traversal, reusing a given buffer.
 *
 * Input Arguments:
 *   travBuff. travBuff->usedBytes will be reset to zero at the start of this function
 *
 * Result Arguments:
 *   travBuff	
 *
 * Return Value:
 *   Returns TRUE if there are no more objects to be returned by subsequent
 *   calls to GciMoreTraversal. Also returns TRUE if the call is terminated
 *   by an error. The contents of the travBuff are undefined in the case of
 *   an error.
 *
 *   Returns FALSE if the traversal is not yet completed,
 *   and GciMoreTraversal can be called again.
 *
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(BoolType) 
GciMoreTraversal(GciTravBufType *travBuff);

/* Nonblocking status constants , 
 *  must agree with hydra GciCalls.java , do not reorder */
typedef enum {
  GCI_RESULT_NOT_READY = 0,		/* nothing happened */
  GCI_RESULT_PROGRESSED = 1,	/* a packet was received */
  GCI_RESULT_READY = 2, /* your result is now ready */
  GCI_RESULT_HAS_ERROR = 3 /* result is ready with error, used in hydra */
  } GciNbProgressEType;

/* =============================================================================
 * GciNbEnd function
 *   Test the status of nonblocking call in progress for completion.
 *
 * Input Arguments:
 *   resultPtr: (void **)
 *     The address at which GciNbEnd should place a pointer to the
 *     result of the nonblocking call when it is complete.
 *     The address is filled in when GciNbEnd returns GCI_RESULT_READY.
 *     Otherwise the address's contents are not modified.
 *     The actual result type is that of the corresponding blocking
 *     GCI call. Because this can be more than one type it is defined
 *     as 'void' and the caller of GciNbEnd will need to do a cast to
 *     the actual result type.
 *     For example the result type of GciNbCommit is
 *     BoolType because that is what GciCommit returns.
 *     The result type of GciNbExecute is OopType because that is
 *     what GciExecute returns.
 *     The value that 'result' points to after GciNbEnd completes
 *     belongs to the GCI and will be modified the next time a
 *     nonblocking GCI call is made.
 *
 * Return Value:
 *   The GciNbEnd function returns an enumerated type.  Its value is
 *   GCI_RESULT_READY if the outstanding nonblocking call has completed
 *   execution and its result is ready, GCI_RESULT_NOT_READY if the call is not
 *   complete and there has been no change since the last inquiry, and
 *   GCI_RESULT_PROGRESSED if the call is not complete but progress has been
 *   made towards its completion.
 *
 *  Note caller has to know whether **resultPtr is a 4 byte or 8 byte value
 *  and dereference *resultPtr accordingly on big endian machines.  
 *  GciNbEnd_ or GciNbEndPoll should be used in new code .
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(GciNbProgressEType) 
GciNbEnd(void **resultPtr);

/* =============================================================================
 *  GciNbEnd_  , GciNbEndPoll
 *
 *   Test the status of nonblocking call in progress for completion.
 * 
 *  Arguments
 *   int64 *vOut
 *     vOut is the address at which GciNbEnd should place the
 *     result of the nonblocking call when it is complete.
 *     The actual result type is that of the corresponding blocking
 *     GCI call, typically   int , BoolType or OopType  , and may be accessed
 *     by normal C casting without regard to byte order of the CPU.
 *     The location for the result is allocated by the caller of GciNbEnd_ ,
 *     typically on the C stack , for example:
 *       GciNbExecute(...)
 *       int64 res;
 *       GciNbProgressEType status = GciNbEnd_(&res, 1000);
 *       ...
 *       OopType resOop = res;
 *
 *    int timeoutMs , number of milliseconds that GciNbEndPoll should wait
 *          for GCI_RESULT_READY status to occur.
 *
 * Return Value:
 *   GciNbEnd_ and GciNbEndPoll return an enumerated type.  Its value is
 *   GCI_RESULT_READY if the outstanding nonblocking call has completed
 *   execution and its result is ready, GCI_RESULT_NOT_READY if the call is not
 *   complete and there has been no change since the last inquiry, and
 *   GCI_RESULT_PROGRESSED if the call is not complete but progress has been
 *   made towards its completion.
 * =============================================================================
 */
  EXTERN_GCI_DEC(GciNbProgressEType)
GciNbEnd_(int64 *vOut);

  EXTERN_GCI_DEC(GciNbProgressEType)
GciNbEndPoll(int64 *vOut, int timeoutMs);

/* =============================================================================
 * GciNbAbort function
 *   Abort the current transaction (nonblocking).
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbAbort(void);

/* =============================================================================
 * GciNbBegin function
 *   Begin a new transaction (nonblocking).
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbBegin(void);

/* =============================================================================
 * GciNbClampedTraverseObjs function
 *   Traverse an array of objects, subject to clamps (nonblocking).
 *
 * For more information, see GciClampedTraverseObjs or the GCI manual.
 *
 *  Deprecated. New code should use GciNbClampedTrav .
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbClampedTraverseObjs(
  OopType clampSpec,
  const OopType theOops[], int numOops, 
  GciTravBufType *travBuff, int level
    );

/* =============================================================================
 * GciNbClampedTrav function
 *   Traverse an array of objects, subject to clamps (nonblocking).
 *
 * For more information, see GciClampedTrav or the GCI manual.
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciNbClampedTrav(
  const OopType *theOops, int numOops,
  GciClampedTravArgsSType *args
  );


/* =============================================================================
 * GciNbCommit function
 *   Write the current transaction to the database (nonblocking).
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbCommit(void);

/* =============================================================================
 * GciNbContinue function
 *   Continue code execution in GemStone after an error (nonblocking).
 *
 * For more information, see GciContinue or the GCI manual.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbContinue(OopType process);


/* =============================================================================
 * GciNbExecute function
 *   Execute a Smalltalk expression contained in a String object
 *   (nonblocking).
 *
 * For more information, see GciExecute or the GCI manual.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbExecute_(OopType source, OopType symbolList, ushort environmentId);

  EXTERN_GCI_DEC(void)
GciNbExecute(OopType source, OopType symbolList);

  EXTERN_GCI_DEC(void) 
GciNbExecuteDbg_(
  OopType source, OopType symbolList,
  int flags /* same as flags to GciPerformNoDebug */, ushort environmentId );

  EXTERN_GCI_DEC(void)
GciNbExecuteDbg(
  OopType source, OopType symbolList,
  int flags /* same as flags to GciPerformNoDebug */);


/* =============================================================================
 * GciNbExecuteStr function
 *   Execute a Smalltalk expression contained in a C string (nonblocking).
 *
 * For more information, see GciExecuteStr or the GCI manual.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbExecuteStr_(const char source[], OopType symbolList, ushort environmentId);

  EXTERN_GCI_DEC(void) 
GciNbExecuteStr(const char source[], OopType symbolList);

  EXTERN_GCI_DEC(void) 
GciNbExecuteStrDbg_(
  const char source[], OopType symbolList ,
  int flags /* same as flags to GciPerformNoDebug */, ushort environmentId);

  EXTERN_GCI_DEC(void) 
GciNbExecuteStrDbg(
  const char source[], OopType symbolList ,
  int flags /* same as flags to GciPerformNoDebug */);


/* =============================================================================
 * GciNbExecuteStrFromContext function
 *   Execute a Smalltalk expression contained in a C string as if it were a
 *   message sent to an object (nonblocking).
 *
 * For more information, see GciExecuteStrFromContext or the GCI manual.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbExecuteStrFromContext_(
  const char source[],
  OopType contextObject, OopType symbolList , ushort environmentId );

  EXTERN_GCI_DEC(void) 
GciNbExecuteStrFromContextDbg_(
  const char source[], int64 sourceSize, OopType sourceClass,
  OopType contextObject, OopType symbolList ,
  int flags /* same as flags to GciPerformNoDebug */, ushort environmentId );

  EXTERN_GCI_DEC(void) 
GciNbExecuteStrFromContext(
  const char source[],
  OopType contextObject, OopType symbolList );

  EXTERN_GCI_DEC(void) 
GciNbExecuteStrFromContextDbg(
  const char source[], int64 sourceSize, OopType sourceClass,
  OopType contextObject, OopType symbolList ,
  int flags /* same as flags to GciPerformNoDebug */);

/* =============================================================================
 * GciNbMoreTraversal function
 *   Continue object traversal, reusing a given buffer (nonblocking).
 *
 * For more information, see GciMoreTraversal or the GCI manual.
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciNbMoreTraversal(GciTravBufType *travBuff);

/* =============================================================================
 * GciNbPerform function
 *   Send a message to a GemStone object (nonblocking).
 *
 * For more information, see GciPerform or the GCI manual.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbPerform(OopType receiver, const char selector[],
  		const OopType args[], int numArgs);

  EXTERN_GCI_DEC(void) 
GciNbPerform_(OopType receiver, const char selector[],
  		const OopType args[], int numArgs, ushort environmentId);

/* =============================================================================
 * GciNbPerformNoDebug function
 *   Send a message to a GemStone object, and temporarily disable debugging
 *   (nonblocking).
 *
 * For more information, see GciPerformNoDebug or the GCI manual.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbPerformNoDebug(OopType receiver, const char selector[],
  		const OopType args[], int numArgs, int flags);

  EXTERN_GCI_DEC(void)  
GciNbPerformNoDebug_(OopType receiver, const char selector[],
                const OopType args[], int numArgs, int flags, ushort environmentId);


/* =============================================================================
 * GciNbPerformTraverse function
 *   Non blocking implementation of GciPerformTraverse.
 *
 *  Deprecated. New code should use GciNbPerformTrav .
 *
 * For more information, see GciPerformTraverse.
 *==============================================================================
 */

  EXTERN_GCI_DEC(void) 
GciNbPerformTraverse_(
  OopType receiver, const char selector[],
  const OopType args[], int numArgs,
  GciTravBufType *travBuff,
  int level, ushort environmentId);

  EXTERN_GCI_DEC(void) 
GciNbPerformTraverse(
  OopType receiver, const char selector[],
  const OopType args[], int numArgs,
  GciTravBufType *travBuff,
  int level);

/* =============================================================================
 * GciNbExecuteStrTrav function
 *   Non blocking implementation of GciExecuteStrTrav
 *
 * For more information, see GciExecuteStrTrav.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbExecuteStrTrav_(
  const char source[], OopType contextObject,
  OopType symbolList,
  GciClampedTravArgsSType *travArgs, ushort environmentId );

  EXTERN_GCI_DEC(void) 
GciNbExecuteStrTrav(
  const char source[], OopType contextObject,
  OopType symbolList,
  GciClampedTravArgsSType *travArgs);

/* =============================================================================
 * GciNbExecuteStrFetchBytes
 *  non blocking implementation of GciExecuteStrFetchBytes
 *==============================================================================
 */
  EXTERN_GCI_DEC(void)
GciNbExecuteStrFetchBytes(const char* source, int64 sourceSize, OopType sourceClass, 
          OopType contextObject, OopType symbolList, 
          ByteType *result, int64 maxResultSize);

/* =============================================================================
 * GciNbPerformTrav function
 *   Non blocking implementation of GciPerformTrav
 *
 * For more information, see GciPerformTrav.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbPerformTrav(
  OopType receiver, const char *selector,
  const OopType *args, int numArgs,
  GciClampedTravArgsSType *travArgs
  );

  EXTERN_GCI_DEC(void) 
GciNbPerformTrav_(
  OopType receiver, const char *selector,
  const OopType *args, int numArgs,
  GciClampedTravArgsSType *travArgs, ushort environmentId
  );

/* =============================================================================
 * GciNbStoreTrav function
 *   Store multiple traversal buffer values in objects (nonblocking).
 *
 * For more information, see GciStoreTrav or the GCI manual.
 * For definitions of "flag", see  GCI_STORE_TRAV constants in gci.ht
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciNbStoreTrav(GciTravBufType *travBuff, int flag);

/* =============================================================================
 * GciNbTraverseObjs function
 *   Traverse an array of GemStone objects (nonblocking).
 *
 * For more information, see GciTraverseObjs or the GCI manual.
 *
 * However, note that the return value is NOT the same as in the blocking call.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNbTraverseObjs(
  const OopType theOops[], int numOops,
  GciTravBufType *travBuff,
  int level
    );

/* =============================================================================
 * GciNewByteObj function
 *   Create and initialize a new byte object.
 *
 * Input Arguments:
 *   aClass	The OOP of the class of which an instance is to be created.
 *   value	Pointer to an array of byte values to be stored in the
 *		newly-created object.
 *   valueSize	The number of byte values in value.
 *
 * Return Value:
 *   The OOP of the newly created object.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciNewByteObj(OopType aClass, const ByteType *value, int64 valueSize);

/* =============================================================================
 * GciNewCharObj function
 *   Create and initialize a new character object.
 *
 * Input Arguments:
 *   aClass	The OOP of the class of which an instance is to be created.
 *              aClass must be a class whose format is BYTE.
 *   cString	Pointer to an array of characters to be stored in the
 *              newly-created object.  The terminating '\0' character is not
 *              stored.
 *
 * Return Value:
 *   The OOP of the newly-created object.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciNewCharObj(OopType aClass, const char *cString);

/* =============================================================================
 * GciNewOop function
 *   Create a new GemStone object.
 *
 * Input Arguments:
 *   oclass	The OOP of the class of which the new object is an instance.
 *              This may be the OOP of a class that you have created, or it may
 *              be one of the Smalltalk kernel classes, such as
 *              OOP_CLASS_STRING for an object of class String.
 *
 * Cannot be used to create instances of Symbol or DoubleByteSymbol
 *
 * Return Value:
 *   Returns the OOP of the new object.  In case of error, this function returns
 *   OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciNewOop(OopType oclass);

/* =============================================================================
 * GciNewOops function
 *   Create multiple new GemStone objects.
 *
 * Input Arguments:
 *   numOops	The number of new objects to be created.
 *   oclass	For each new object, the OOP of its class.
 *   idxSize	For each new object, the number of its indexed variables.  If
 *              the specified oclass of an object is not indexable, its idxSize
 *              is ignored.
 *
 *
 * Cannot be used to create instances of Symbol or DoubleByteSymbol
 *
 * Result Arguments:
 *   result	An array of the OOPs of the new objects created with this
 *              function.
 *
 * Return Value:
 *   If an error is encountered, this function will stop at the first error and
 *   the contents of the result array will be undefined.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNewOops(
  int numOops, const OopType oclass[],
  const int64 idxSize[], OopType result[] 
    );

/* =============================================================================
 * GciNewOopUsingObjRep function
 *   Create a new GemStone object from an existing object report.
 *
 * Input Arguments:
 *   anObjectReport	A pointer to an object report.
 *
 * Result Arguments:
 *   anObjectReport	A modified object report that contains the OOP of the
 *                      new object (hdr.objId), the object's segment
 *                      (hdr.segment), the number of named instance variables in
 *                      the object (hdr.namedSize), the updated number of the
 *                      object's indexed variables (hdr.idxSize), and the
 *                      object's complete size (the sum of its named and
 *                      unnamed variables, hdr.objSize).
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciNewOopUsingObjRep(GciObjRepSType *anObjectReport);

/* =============================================================================
 * GciNewString function
 *   Create a new String object from a C character string.
 *
 * Input Arguments:
 *   cString	Pointer to a character string.
 *
 * Return Value:
 *   The OOP of the newly created object.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciNewString(const char *cString);

/* =============================================================================
 * GciNewSymbol function
 *   Create a new Symbol object from a C character string.
 *
 * Input Arguments:
 *   cString	Pointer to a character string.
 *
 * Return Value:
 *   The OOP of the newly created object.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciNewSymbol(const char *cString);

/* =============================================================================
 * GciNewUtf8String
 *
 * Create a Unicode string object.
 *
 * utf8data   a pointer to UTF-8 encoded data, terminated by a zero byte.
 *
 * If convertToUnicode==0, returns an instance of Utf8 .
 *
 * If convertToUnicode==1, returns an instance of
 * Unicode7, Unicode16, or Unicode32 using the minimal
 * character size required to represent utf8data.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType)
GciNewUtf8String(const char* utf8data, BoolType convertToUnicode);

/* =============================================================================
 * GciNewUtf8String_
 *
 * Create a Unicode string object.
 *
 * utf8data  a pointer to UTF-8 encoded data .
 *
 * nBytes    specifies the length in bytes of the UTF-8 data .
 *
 * If convertToUnicode==0, returns an instance of Utf8 .
 *
 * If convertToUnicode==1, returns an instance of
 * Unicode7, Unicode16, or Unicode32 using the minimal
 * character size required to represent utf8data.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType)
GciNewUtf8String_(const char* utf8data, size_t nBytes, BoolType convertToUnicode);


/* =============================================================================
 * GciObjExists function
 *   Determine whether or not a GemStone object exists.
 *
 * Input Arguments:
 *   theObject	The OOP of an object.
 *
 * Return Value:
 *   Returns TRUE if theObject exists, FALSE otherwise.
 *   If theObject is a place holder for an unsatisfied forward reference, 
 *   returns FALSE.
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(BoolType) 
GciObjExists(OopType obj);

/* =============================================================================
 * GciObjInCollection function
 *   Determine whether or not a GemStone object is in a Collection.
 *
 * Input Arguments:
 *   anObj	The OOP of an object for which to check.
 *   aCollection	The OOP of a collection.
 *
 * Return Value:
 *   Returns TRUE if anObj exists in aCollection, FALSE otherwise.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciObjInCollection(OopType anObj, OopType aCollection);

/* =============================================================================
 * GciObjRepSize function
 *   Find the number of bytes in an object report.
 *
 * Input Arguments:
 *   anObjectReport	A pointer to an object report returned by GciFindObjRep.
 *
 * Return Value:
 *   Returns the size of the specified object report.
 *==============================================================================
 */
  EXTERN_GCI_DEC(size_t) 
GciObjRepSize_(const GciObjRepHdrSType *anObjectReport);

/* =============================================================================
 * GciOopToBool function
 *   Convert a Boolean object to a C Boolean value.
 *
 * Input Arguments:
 *   theObject	The OOP of the Boolean object to be translated into a C Boolean
 *              value.
 *
 * Return Value:
 *   Returns the C Boolean value that corresponds to the GemStone object.  In
 *   case of error, this function returns FALSE.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciOopToBool(OopType theObject);

/* =============================================================================
 * GciOopToChr function
 *   Convert a Character object to an 8 bit C character value.
 *
 * Input Arguments:
 *   theObject	The OOP of the Character object to be translated into a C
 *              character value.
 *
 * Return Value:
 *   Returns the C character value that corresponds to the GemStone object.  In
 *   case of error, this function returns zero.
 *==============================================================================
 */
  EXTERN_GCI_DEC(char) 
GciOopToChr(OopType theObject);

/* =============================================================================
 * GciOopToChar16 function
 *   Convert a Character object to a 16 bit C character value.
 *
 * Input Arguments:
 *   theObject	Character object to be translated into a C
 *              character value.
 *
 * Return Value:
 *   Returns the C character value that corresponds to the GemStone object.  In
 *   case of error, this function returns zero.
 *==============================================================================
 */
  EXTERN_GCI_DEC(unsigned short)
GciOopToChar16(OopType theObject);

/* =============================================================================
 * GciOopToChar32 function
 *   Convert a Character object to a 32 bit C character value.
 *
 * Input Arguments:
 *   theObject	Character object to be translated into a C
 *              character value.
 *
 * Return Value:
 *   Returns the C character value that corresponds to the GemStone object.  In
 *   case of error, this function returns zero.
 *==============================================================================
 */
  EXTERN_GCI_DEC(unsigned int) 
GciOopToChar32(OopType theObject);

/* =============================================================================
 * GciOopToFlt function
 *   Convert a SmallDouble, SmallFloat or Float object to a C double value.
 *
 * Input Arguments:
 *   theObject	The OOP of the Float object to be translated into a C floating
 *              point value.  If theObject is neither a SmallFloat nor a Float,
 * 		an error is generated.
 *
 * Return Value:
 *   Returns the C double precision value that corresponds to the GemStone
 *   object.  In case of an error this function returns a PlusQuietNaN.
 *==============================================================================
 */
  EXTERN_GCI_DEC(double) 
GciOopToFlt(OopType theObject);

/* =============================================================================
 * GciPathToStr function
 *
 *  Deprecated.
 *
 *   Convert a path representation from numeric to string.
 *
 * Input Arguments:
 *   aClass	The class of the object for which this path will apply.  That
 *              is, for each instance of this class, store or fetch objects
 *              along the designated path.
 *   path	The path array to be converted to string format.
 *   pathSize	The number of integers in the path array.
 *   maxResultSize
 *              The maximum allowable length of the resulting path string,
 *              excluding the null terminator.
 *
 * Result Arguments:
 *   result	The resulting path string, terminated with a null character.
 *              The resulting string is of the form foo.bar.name.  Each element
 *              of the path string is the name of an instance variable (that is,
 *              bar is an instance variable of foo, and name is an instance
 *              variable of bar).
 *
 * Return Value:
 *   Returns TRUE if the path array was successfully converted to a string.
 *   Returns FALSE otherwise.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciPathToStr(
  OopType aClass,
  const int path[], int pathSize,
  int64 maxResultSize, char result[] 
    );

/* =============================================================================
 * GciPerform , GciPerform_ functions
 *   Send a message to a GemStone object.
 *
 * Input Arguments:
 *   receiver	The OOP of the receiver of the message.
 *   selector	A string that defines the message selector.  For keyword
 *              selectors, all keywords are concatenated in the string. (For
 *              example, at:put:).
 *   args	An array of OOPs.  Each element in the array corresponds to an
 *              argument for the message.  If there are no message arguments,
 *              use a dummy OOP here.
 *   numArgs	The number of arguments to the message.  For unary selectors
 *              (messages with no arguments), numArgs is zero.
 *
 *   environmentId  a compilation environment identifier, normally zero for Smalltalk
 *
 * Return Value:
 *   Returns the OOP of the result of Smalltalk execution.  In case of error,
 *   this function returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType)
GciPerform(OopType receiver, const char selector[],
         const OopType args[], int numArgs );

  EXTERN_GCI_DEC(OopType) 
GciPerform_(OopType receiver, const char selector[],
         const OopType args[], int numArgs , ushort environmentId);

/* =============================================================================
 * GciPerformSymDbg , GciPerformSymDbg_ functions
 *   Send a message to a GemStone object, using a String object as a selector.
 *
 * Input Arguments:
 *   receiver	The OOP of the receiver of the message.
 *   selector	The OOP of a String object that defines the message selector.
 *              For keyword selectors, all keywords are concatenated in the
 *              string. (For example, at:put:).
 *   args	An array of OOPs.  Each element in the array corresponds to an
 *              argument for the message.  If there are no message arguments,
 *              use a dummy OOP here.
 *   numArgs	The number of arguments to the message.  For unary selectors
 *              (messages with no arguments), numArgs is zero.
 *   flags	per flags arg to GciPerformNoDebug
 *
 *   environmentId  a compilation environment identifier, normally zero for Smalltalk
 *
 * Return Value:
 *   Returns the OOP of the result of Smalltalk execution.  In case of error,
 *   this function returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciPerformSymDbg(OopType receiver, OopType selector,
 	const OopType args[], int numArgs, int flags );

  EXTERN_GCI_DEC(OopType) 
GciPerformSymDbg_(OopType receiver, OopType selector,
      const OopType args[], int numArgs, int flags, ushort environmentId);

/* =============================================================================
 * GciPerformNoDebug, GciPerformNoDebug_ functions
 *   Send a message to a GemStone object, and possibly debugging.
 *   This function is typically used in the
 *   implementation of user interfaces for Smalltalk debuggers .
 *
 * Input Arguments:
 *   receiver	The OOP of the receiver of the message.
 *   selector	A string that defines the message selector.  For keyword
 *              selectors, all keywords are concatenated in the string. (For
 *              example, at:put:).
 *   args	An array of OOPs.  Each element in the array corresponds to an
 *              argument for the message.  If there are no message arguments,
 *              use a dummy OOP here.
 *   numArgs	The number of arguments to the message.  For unary selectors
 *              (messages with no arguments), numArgs is zero.
 *
 *   flags      zero, or one of bits per GCI_PERFORM_FLAG* in gcicmn.ht
 *
 *   environmentId  a compilation environment identifier, normally zero for Smalltalk
 *
 * Return Value:
 *   Returns the OOP of the result of Smalltalk execution.  In case of error,
 *   this function returns OOP_NIL.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciPerformNoDebug( OopType receiver, const char selector[],
  	const OopType args[], int numArgs, int flags);

  EXTERN_GCI_DEC(OopType) 
GciPerformNoDebug_( OopType receiver, const char selector[],
  	const OopType args[], int numArgs, int flags, ushort environmentId);

/* ==========================================================================
 * GciPerformTraverse
 *   Do the equivalent of GciPerform using the first 4 arguments, and
 *   then perform a GciTraverseObjs, starting from the result of the perform,
 *   and doing a traversal as specified by the last 4 arguments.
 *
 *   The result of the GciPerform will be the last object in the resulting
 *   travBuff
 *
 *   Function result - 
 *     TRUE if the result is complete and no errors occured;
 *     FALSE if the traversal is not complete, in which case,
 *       if there is no GciError, GciMoreTraversal may be called to continue 
 *       the traversal.
 *
 * ==========================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciPerformTraverse( OopType receiver, const char selector[],
  	const OopType args[], int numArgs, GciTravBufType *travBuff,
  	int level);

  EXTERN_GCI_DEC(BoolType) 
GciPerformTraverse_( OopType receiver, const char selector[],
  	const OopType args[], int numArgs, GciTravBufType *travBuff,
  	int level, ushort environmentId);

/* ==========================================================================
 * GciPerformTrav
 *   Do the equivalent of GciPerform using the first 4 arguments, and
 *   then perform a GciClampedTrav, starting from the result of the perform,
 *   and doing a traversal as specified by  travArgs.
 *
 *   See GciClampedTrav for documentation of  travArgs  argument.
 *
 *   The result of the GciPerform will be the last object in the resulting
 *   travArgs->travBuff unless the oop had an identity clamp.
 *   It will always be in travArgs->resultOop.
 *
 *   Function result - 
 *     TRUE if the result is complete and no errors occured;
 *     FALSE if the traversal is not complete, in which case,
 *       if there is no GciError, GciMoreTraversal may be called to continue 
 *       the traversal.
 *
 * ==========================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciPerformTrav( OopType receiver, const char *selector,
  	const OopType *args, int numArgs, GciClampedTravArgsSType *travArgs);

  EXTERN_GCI_DEC(BoolType) 
GciPerformTrav_( OopType receiver, const char *selector,
  	const OopType *args, int numArgs, GciClampedTravArgsSType *travArgs,
	ushort environmentId);

/* ============================================================================
 * GciExecuteStrTrav function
 *   Do the equivalent of GciExecuteStrContext using the first 4 arguments, and
 *   then perform a GciClampedTrav, starting from the result of the execute,
 *   and doing a traversal as specified by  travArgs.
 *
 *   Execute a Smalltalk expression contained in a C string as if it were a
 *   message sent to an object.
 *
 * Input Arguments:
 *   source	A null-terminated string containing a sequence of one or more
 *              statements to be executed.
 *   contextObject
 *		The OOP of any GemStone object.
 *              A value of OOP_NO_CONTEXT means no context.
 *   symbolList	The OOP of a GemStone symbol list (that is, an Array of
 *              instances of SymbolDictionary).  The compiler uses the
 *              symbolList to resolve symbolic references in the code in source.
 *              A value of OOP_NIL means to use the default symbol list for the
 *              current GemStone session (that is, System myUserProfile
 *              symbolList).
 *
 *   See GciClampedTrav for documentation of  travArgs  argument.
 *
 *   The result of the GciExecuteStrContext will be the last object
 *   in the resulting travArgs->travBuff unless the oop had an identity clamp.
 *   It will always be in travArgs->resultOop.
 *
 *   Function result - 
 *     TRUE if the result is complete and no errors occured;
 *     FALSE if the traversal is not complete, in which case,
 *       if there is no GciError, GciMoreTraversal may be called to continue 
 *       the traversal.
 *=============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciExecuteStrTrav(
  const char source[], OopType contextObject,
  OopType symbolList,
  GciClampedTravArgsSType *travArgs);

  EXTERN_GCI_DEC(BoolType) 
GciExecuteStrTrav_(
  const char source[], OopType contextObject,
  OopType symbolList,
  GciClampedTravArgsSType *travArgs, ushort environmentId );

/*=============================================================================
 * GciProcessDeferredUpdates
 *
 * Equivalent to GciExecuteStr("System _processDeferredGciUpdates", OOP_NIL);
 * Function result: number of objects which had deferred updates
 *
 * Description:
 * 
 * A new bit has been defined in the format instVar of Behavior.
 * This bit is 16r200,  "noStructuralUpdate"
 * 
 * In gcioc.ht you will find
 *  define GC_FORMAT_NO_STRUCT_UPDATE      0x200
 * 
 * A new bit is defined in the flags argument to GciStoreTrav,
 * in gci.ht:
 *  define GCI_STORE_TRAV_FINISH_UPDATES 0x8
 * 
 * The following classes have the noStructuralUpdate bit set.  This is inherited
 * by all subclasses of these classes:
 *   AbstractDictionary
 *   Bag
 *   Set
 * After Gci operations which may have modified an instance of one of these
 * operations,  GciProcessDeferredUpdates(void) must be called, or the final
 * GciStoreTrav must have GCI_STORE_TRAV_FINISH_UPDATES set.
 * 
 * Any attempt to commit will automatically execute
 *   System _processDeferredGciUpdates
 * 
 * If _processDeferredGciUpdates is executed prior to resolving all forward
 * references, errors may occur, and recovery from such errors
 * may require the appliation to either GciAbort or GciLogout.
 * 
 * The following GCI calls will operate on instances whose class has
 * noStructuralUpdate set.  Behavior of other GCI update calls on such
 * instances is undefined.
 * 
 *   GciCreateOopObj
 *   GciStoreTrav
 *   GciStore*Oops
 *   GciAdd*Oops
 *   GciReplace*Oops
 * 
 * An oop buffer used to update the varying portion of an object with 
 * noStructuralUpdate must contain the oops to be added to the varying portion
 * of the object.  Exceptions:
 *   If the object is a kind of KeyValueDictionary that does not store 
 *   Associations, the buffer must contain (key, value) pairs.
 * 
 *   If the object is a kind of AbstractDictionary that stores Associations or
 *   (key, Association) pairs, the value buffer must contain Associations.
 * 
 *  uses method environmentId == 0
 *=============================================================================
 */
  EXTERN_GCI_DEC(int64) 
GciProcessDeferredUpdates_(void);

/* ==========================================================================
 * GciPollForSignal
 * 
 *  Polls the database to see if any of the following errors are pending,
 *  without the cost of starting Smalltalk execution.  These 3 errors
 *  are only seen by this function, if the corresponding method in class
 *  System has been used to enable the receipt of Smalltalk signals for
 *  that error.
 *   
 *    error                            method to enable receipt of error
 *      RT_ERR_SIGNAL_ABORT              enableSignaledAbortError
 *      RT_ERR_SIGNAL_COMMIT             enableSignaledObjectsError
 *      RT_ERR_SIGNAL_GEMSTONE_SESSION   enableSignaledGemStoneSessionError
 *
 *  This function is useful to test for these 3 errors, if 
 *  GciEnableSignaledErrors is not used to enable checking on every GCI call.
 *  Only those errors previously enabled by appropriate methods in class
 *  System will be checked.
 *  
 *  In addition, this function will detect any other asynchronous errors
 *  whenever they occur, including:
 *      ABORT_ERR_LOST_OT_ROOT, GS_ERR_SHRPC_CONNECTION_FAILURE,
 *      GS_ERR_STN_NET_LOST, GS_ERR_STN_SHUTDOWN, GS_ERR_SESSION_SHUTDOWN
 *  
 *  Function result: TRUE if an error exists; in that case, the
 *    error is available via GciErr, or the error will have caused a 
 *    longjmp if a jmp_buf was active for the current session.
 * ==========================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(BoolType) 
GciPollForSignal(void);
 
/* ==========================================================================
 * GciPollSocketForRead
 *
 *  Wait for the specified socket to be read-ready or to have an error .
 *  Returns 0 if timed out .
 *  Returns 1 if socket is ready for read,
 *  Returns a value is < 0  if an error occurred (result is a negated errno value).
 *
 *  This function retrys the poll on EINTR , even if a SIGTERM was received.
 *  Thread safe function, has no relationship to the current GCI session .
 * ==========================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(int)
GciPollSocketForRead(int socketFd, int timeoutMs);


/* =============================================================================
 * GciPopErrJump function
 *   Discard a previously saved error jump buffer.
 *
 * Input Arguments:
 *   jumpBuffer	A pointer to a jump buffer specified in an earlier call to
 *   GciPushErrJump or GciPushErrHandler.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciPopErrJump(GciJmpBufSType *jumpBuffer);

/* ================================================================ 
 * GciJmpBufSType, Gci jump buffer type .
 *
 * Instances of this type must be initialized by using Gci_SETJMP()
 */

/* ================================================================ 
 *  Gci_SETJMP   
 *     except for difference in argument type, the
 *     semantics are the same as setjmp() on Solaris and Win32,
 *     semantics are the same as _setjmp() on HPUX  .
 *
 *   The argument is expected to be of type   GciJmpBufSType*
 *
 * new in Gemstone64, replaces GCI_SETJMP
 */
#if defined(FLG_SETJMP_BSD)
#define Gci_SETJMP(aBuf) _setjmp((aBuf)->buf)
#else
#define Gci_SETJMP(aBuf) setjmp((aBuf)->buf)
#endif


/* ================================================================ 
 * GciLongJmp  
 *   except for difference in type of first argument, 
 *     semantics are the same as longjmp() on Solaris and Win32,
 *     semantics are the same as _longjmp() on HPUX  .
 *
 * new in Gemstone64, replaces GCI_LONGJMP
 */ 
EXTERN_GCI_DEC(void) 
   GciLongJmp(GciJmpBufSType *buf, int val);

/* =============================================================================
 * GciPushErrJump function
 *   Associate GCI error handling with a jump buffer by pushing a jump buffer
 *   onto the stack.
 *
 * Arguments:
 *   jumpBuffer	  A pointer to a jump buffer. jumpBuffer must have been 
 *       initialized by passing it as the argument to Gci_SETJMP
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciPushErrJump(GciJmpBufSType *jumpBuffer);

/* =============================================================================
 * GciReleaseAllOops function      (behavior has changed in Gemstone64)
 *
 * If called from a user action
 *   resets the user action's export set to empty
 * else
 *   resets the session's PureExportSet to empty .
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciReleaseAllOops(void);

/* =============================================================================
 * GciReleaseAllGlobalOops
 *
 * Resets the session's PureExportSet to empty.  Functionality is independent
 * of whether called from within a user action.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void)
GciReleaseAllGlobalOops(void);


/* =============================================================================
 * GciReleaseAllTrackedOops function
 *
 * Set the GciTrackedObjs set to empty.  
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciReleaseAllTrackedOops(void);

/* =============================================================================
 * GciReleaseOops function              (behavior has changed in Gemstone64)
 *
 *  If called from a user action
 *   removes specified objects from the user action's export set
 *  else
 *   removes specified objects from the session's PureExportSet
 *
 * Input Arguments:
 *   theOops    An array of OOPs.  Each element of the array corresponds to an
 *              object to be released.
 *   numOops    The number of elements in theOops.
 *
 *  Has no effect on oops which have previously been accumulated
 *  in the list to be returned by GciDirtySaveObjs.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciReleaseOops(const OopType theOops[], int numOops);

/* ============================================================================= 
 * GciReleaseGlobalOops
 *
 * Removes specified objects from the session's PureExportSet.  Functionality
 * is independent of whether called from a user action.
 *
 * See also GciReleaseOops, GciSaveGlobalObjs
 *==============================================================================
 */
  EXTERN_GCI_DEC(void)
GciReleaseGlobalOops(const OopType theOops[], int numOops);

/* =============================================================================
 * GciReleaseTrackedOops function
 *   Remove an array of GemStone OOPs from the GciTrackedObjs set .
 *
 * Input Arguments:
 *   theOops	An array of OOPs.  Each element of the array corresponds to an
 *              object to be released.
 *   numOops	The number of elements in theOops.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciReleaseTrackedOops(const OopType theOops[], int numOops);

/* =============================================================================
 * GciRemoveOopFromNsc function
 *   Remove an OOP from an NSC.
 *
 * Input Arguments:
 *   theNsc	The OOP of the NSC from which to remove an OOP.
 *   theOop	The OOP of the object to be removed.
 *
 * Return Value:
 *   Returns FALSE if theOop was not present in the NSC.  Returns TRUE if theOop
 *   was present in the NSC.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciRemoveOopFromNsc(OopType theNsc, OopType theOop);

/* =============================================================================
 * GciRemoveOopsFromNsc function
 *   Remove one or more OOPs from an NSC.
 *
 * Input Arguments:
 *   theNsc	The OOP of the NSC from which to remove the OOPs.
 *   theOops	The array of OOPs to be removed from the NSC.
 *   numOops	The number of OOPs to remove.
 *
 * Return Value:
 *   Returns FALSE if any element of theOops was not present in the NSC.
 *   Returns TRUE if all elements of theOops were present in the NSC.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciRemoveOopsFromNsc(
  OopType theNsc, const OopType theOops[],
  int numOops 
    );


/* =============================================================================
 * GciReplaceOops function
 *
 *   Replaces the contents of all instance variables in theObj with theOops[]
 *   For indexable or Nsc objects, the varying size of theObj is set to
 *   MAX(0, numOops - namedSize).
 *   For Nsc objects, any values provided for private named instance 
 *   variables are silently ignored and passed over when doing the store.
 *
 * Input Arguments:
 *   theOops	The array of OOPs used as the replacements.
 *   numOops	The number of OOPs in theOops.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciReplaceOops(
  OopType theObj, const OopType theOops[],
  int numOops
    );

/* =============================================================================
 * GciReplaceVaryingOops function
 *   Replace all unnamed instance variables of an Nsc or indexable instance
 *   variables of an indexable pointer object .
 *
 * Input Arguments:
 *   theObject  object to be modified.
 *   theOops	The array of objects used as the replacements.
 *   numOops	The number of objects in theOops.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciReplaceVaryingOops(
  OopType theObject, const OopType theOops[],
  int numOops
    );

/* =============================================================================
 * GciResolveSymbol function
 *   Find the OOP of the object to which a symbol name refers, in the context of
 *   the current session's user profile.  Equivalent to GciResolveSymbolObj
 *   except that the value of a symbol is an input instead of an object
 *   identifer.
 *
 * Input Arguments:
 *   cString	The value of a symbol as a character string.
 *   symbolList	The OOP of an instance of OOP_CLASS_SYMBOL_LIST or OOP_NIL.
 *
 * Return Value:
 *    The object to which cString resolves, or OOP_ILLEGAL if aSymbolObj
 *    does not exist in the symbolList .
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciResolveSymbol(const char *cString , OopType symbolList);

/* =======================================================================
 * GciResolveSymbolObj
 *   attempts to resolve aString using symbol list symbolList .
 *   If symbolList is OOP_NIL, this is equivalent to the Smalltalk 
 *       System myUserProfile resolveSymbol: aString
 *
 *  If symbol not found or an error generated, result is OOP_ILLEGAL.
 *  If result is OOP_ILLEGAL, and GciErr reports no error,
 *  then the symbol could not be resolved using the given symbollist,
 *  If an error such as authorization error occurs, the result will be
 *  OOP_ILLEGAL and the error will be accessible by GciErr.
 *
 *  Arguments -
 *   aString   - a kind of String or MultiByteString
 *   symboList - OOP_NIL (means default symbolList) or an instance of
 *                 OOP_CLASS_SYMBOL_LIST
 *
 *  Return value
 *    The object to which aString resolves, or OOP_ILLEGAL if aString
 *    does not exist in the symbolList .
 * =======================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciResolveSymbolObj(OopType aString, OopType symbolList);

/* ==========================================================================
 *  GciSaveObjs			(behavior has changed in Gemstone64)
 *
 *  If called from a user action 
 *     adds specified objects to the user action's exportSet, 
 *  else 
 *    adds the specified objects to the sessions internal PureExportSet.
 *    to prevent their being garabage collected.
 *
 *  The user action's export set does not contributed to objects appearing
 *  in the ExportedDirtyObjs set .
 *
 *  This will prevent Gemstone garbage collection from causing
 *  the objects to disappear during a session because they are unreferenced.
 *  Does NOT cause the objects to be referenced from a permanent object,
 *  and thus there is no guarantee that they will be saved to disk at commit.
 *
 *   Note that for results of GciNew*, GciCreate*, GciSend*, GciPerform*, 
 *   GciExecute* GciResolve*  and GciI64ToOop 
 *   an automatic GciSaveObjs() is performed with the results as argument.
 *   GciRelease* calls may be used to cancel the effect of a GciSaveObjs call, 
 *   thus making objects eligible for garbage collection.
 *
 *   See also GciDirtyExportedObjs() .
 *
 *    arguments: theOops, an array of oops,
 *               numOops, the number of elements in theOops
 * ==========================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciSaveObjs(const OopType theOops[], int numOops);

/* ==========================================================================
 * GciSaveGlobalObjs
 *  Adds the specified objects to the sessions internal PureExportSet.
 * 
 *  Functionality is independent of whether called from a user action.
 *  See also GciSaveObjs().

 *  Use GciReleaseGlobalObjs() to remove
 *  objects from PureExportSet independent of user action state
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void)
GciSaveGlobalObjs(const OopType theOops[], int numOops);


/* ==========================================================================
 *  GciSaveAndTrackObjs
 *    Adds the specified objects to the GemStone's internal GciTrackedObjs set.
 *    to prevent their being garabage collected and so that changes to
 *    these objects will show up in the TrackedDirtyObjs set.
 *
 *    The GciTrackedObjs set is separate from the PureExportSet.  
 *    If an object is in the GciTrackedObjs set, it is protected from 
 *    garbage collection.
 *
 *    Does NOT cause the objects to be referenced from a permanent object,
 *    and thus there is no guarantee that they will be saved to disk at commit.
 *
 *   Note that results of GciNew*, GciCreate*, GciSend*, GciPerform*, and
 *   GciExecute* calls are automatically added to a user action's export set
 *    or to the PureExportSet as specified under GciSaveObjs().
 *
 *   GciReleaseTrackedOops() may be used to cancel a GciSaveAndTrackObjs() 
 *   call and make objects eligible for garbage collection.
 *
 *   See also GciDirtyTrackedObjs() .
 *
 *    arguments: theOops, an array of oops,
 *               numOops, the number of elements in theOops
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciSaveAndTrackObjs(const OopType theOops[], int numOops);

// =============================================================================
//
// GciSendMsg no longer uses variable arguments.  New code should use GciPerform() .
// For convenience,  inline implementations of GciSendMsg are provided in ./gcisend.hf

/* =============================================================================
 * GciSetErrJump function
 *   Enable or disable the current error handler.
 *
 * Input Arguments:
 *   aBoolean	TRUE enables error jumps to the execution environment saved by
 *              the most recent GciPushErrJump or GciPushErrHandler; FALSE
 *              disables error jumps.
 *
 * Return Value:
 *   Returns TRUE if error handling was previously enabled for the jump buffer
 *   at the top of the error jump stack.  Returns FALSE if error handling was
 *   previously disabled.  If your program has no buffers saved in its error
 *   jump stack, this function returns FALSE.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciSetErrJump(BoolType aBoolean);

/* =============================================================================
 * GciSetNet function
 *   Set network parameters for connecting the user to the Gem and Stone
 *   processes.
 *
 * Input Arguments:
 *   StoneName	Network resource string for the database monitor process.
 *   HostUserId	Login name.
 *   HostPassword
 *              Password of the user.
 *   GemService	Network resource string for the GemStone service.
 *   If GemService is an empty string,  "",  then 
 *     if (GciIsRemote() == FALSE && GciInUserAction == FALSE)
 *        default service is "gcilnkobj"  
 *     else 
 *        default service is "gemnetobject"
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciSetNet(
  const char StoneName[],
  const char HostUserId[],
  const char HostPassword[],
  const char GemService[]
  );


/* =============================================================================
 * GciSetSessionId function
 *   Set an active session to be the current one.
 *
 * Input Arguments:
 *   sessionId	The session ID of an active (logged-in) GemStone session.
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciSetSessionId(GciSessionIdType sessionId);

/* ==========================================================================
 *  GciShutdown
 *    intended to be called by imageExit routines
 *    In Linkable Gci calls GciLogout.
 *    For Rpc Gci, logs out all sessions and shuts down networking layer,
 *     thus releasing memory allocated by the Gci.
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciShutdown(void);

/* =============================================================================
 * GciSoftBreak function
 *
 *   Interrupt the execution of SmalltalkDB code, but permit it to be
 *   restarted.
 *
 *  Gs64 v3.2 , has no effect if called from within a user action.
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciSoftBreak(void);


/* =============================================================================
 * GciStep, GciStep_   functions
 *
 *  Deprecated , debuggers should use instance methods in GsProcess.
 *
 *   Continue code execution in GemStone with specified single step
 *   semantics. Intended for use by debuggers.
 *
 * Input Arguments:
 *   process	The OOP of a GsProcess object (obtained as the value of the
 *              context field of an error report returned by GciErr).
 *
 *   level  0 means step-into semantics starting from top of stack
 *          1 means step-over semantics starting from top of stack
 *          > 1 means step-over semantics from specified level on stack.
 *
 *   level < 0 or (level > GciPerform(aProcess, "stackDepth, NULL, 0))
 *          will generate an error
 *
 *   through == TRUE and level == 1 gives step through semantics, stopping
 *         in blocks for which top of stack frame is home method 
 *
 * Return Value:
 *   Returns the OOP of the result of the Smalltalk code that was executed.
 *   Returns OOP_ILLEGAL in case of error.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciStep(OopType process, int level); /* through == FALSE */

  EXTERN_GCI_DEC(OopType) 
GciStep_(OopType process, int level, BoolType through);

  EXTERN_GCI_DEC(void) 
GciNbStep(OopType process,int    level); /* through == FALSE */
  /* non blocking variant of GciStep , use GciNbEnd_ to get result */

  EXTERN_GCI_DEC(void) 
GciNbStep_(OopType process,int level, BoolType through);

/* =============================================================================
 * GciStoreByte function
 *   Store one byte in a byte object.
 *
 * Input Arguments:
 *   theObject	The OOP of the GemStone byte object.
 *   atIndex	The index into theObject at which to store the byte.
 *   theByte	The 8-bit value to be stored.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStoreByte(OopType theObject, int64 atIndex, ByteType theByte);

/*=======================================================================
 *  GciStoreBytesInstanceOf
 *
 * If theClass != OOP_NIL, and theObject does not match "theClass" 
 * an error will be generated.
 *
 * Gs64 v3.0:
 * For an object with multiple bytes per character or digit,
 * "theBytes" is assumed to be in client native byte order,
 * and will be swizzled if needed on the server. Also, startIndex
 * and numBytes must be aligned on character/digit boundaries.
 *=======================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStoreBytesInstanceOf(
  OopType theClass,  
  OopType theObject, int64 startIndex,
  const ByteType theBytes[], int64 numBytes 
    );

/* =======================================================================
 *  GciStoreBytes
 *
 *  Stores bytes into an object which must have byte format.
 *  For an object with multiple bytes per character or digit,
 *  "theBytes" is expected to be in client native byte order,
 *  and will be swizzled if needed by the server.
 *=======================================================================
 */
#define GciStoreBytes(theObject, startIndex, theBytes, numBytes) \
  GciStoreBytesInstanceOf(OOP_NIL, theObject, startIndex, theBytes, numBytes)

/*=======================================================================
 * GciStoreChars
 *  equivalent to GciStoreBytes, except that it is assummed that aString
 *  contains ASCII text terminated by a NUL character.
 *=======================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStoreChars(
  OopType theObject, int64 startIndex,
  const char *aString
    );

/* =============================================================================
 * GciStoreIdxOop function
 *   Store one OOP in a pointer object's unnamed instance variable.
 *
 * Input Arguments:
 *   theObject	The pointer object.
 *   atIndex	The index into theObject at which to store the object.
 *   theOop	The OOP to be stored.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStoreIdxOop(
  OopType theObject, int64 atIndex, OopType theOop 
    );

/* =============================================================================
 * GciStoreIdxOops function
 *   Store one or more OOPs in a pointer object's unnamed instance variables.
 *
 * Input Arguments:
 *   theObject	The pointer object.
 *   startIndex	The index into theObject at which to begin storing OOPs.
 *   theOops	The array of OOPs to be stored.
 *   numOops	The number of OOPs to store.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStoreIdxOops(
  OopType theObject, int64 startIndex,
  const OopType theOops[], int numOops 
    );

/* =============================================================================
 * GciStoreNamedOop function
 *   Store one OOP into an object's named instance variable.
 *
 * Input Arguments:
 *   theObject	The object in which to store the OOP.
 *   atIndex	The index into theObject's named instance variables at which to
 *              store the OOP.
 *   theOop	The OOP to be stored.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStoreNamedOop(OopType theObject, int64 atIndex, OopType theOop);

/* =============================================================================
 * GciStoreNamedOops function
 *   Store one or more OOPs into an object's named instance variables.
 *
 * Input Arguments:
 *   theObject	The object in which to store the OOPs.
 *   startIndex	The index into theObject's named instance variables at which to
 *              begin storing OOPs.
 *   theOops	The array of OOPs to be stored.
 *   numOops	The number of OOPs to store.  If (numOops+startIndex) exceeds
 *              the number of named instance variables in theObject, an error is
 *              generated.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStoreNamedOops(
  OopType theObject, int64 startIndex,
  const OopType theOops[], int numOops 
    );

/* =============================================================================
 * GciStoreOop function
 *   Store one OOP into an object's instance variable.
 *
 * Input Arguments:
 *   theObject	The object in which to store the OOP.
 *   atIndex	The index into theObject at which to store the OOP.  This
 *              function does not distinguish between named and unnamed instance
 *              variables.  Indices are based at the beginning of an object's
 *              array of instance variables.  In that array, the object's named
 *              instance variables are followed by its unnamed instance
 *              variables.
 *   theOop	The OOP to be stored.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStoreOop(
  OopType theObject, int64 atIndex, OopType theOop 
    );

/* =============================================================================
 * GciStoreOops function
 *   Store one or more OOPs into an object's instance variables.
 *
 * Input Arguments:
 *   theObject	The object in which to store the OOPs.
 *   startIndex	The index into theObject at which to begin storing OOPs.  This
 *              function does not distinguish between named and unnamed instance
 *              variables. Indices are based at the beginning of an object's 
 *              array of instance variables.  In that array, the object's named 
 *              instance variables are followed by its unnamed instance
 *              variables.
 *   theOops	The array of OOPs to be stored.
 *   numOops	The number of OOPs to store.
 *
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStoreOops(
  OopType theObject, int64 startIndex,
  const OopType theOops[], int numOops
    );

/* =============================================================================
 * GciStorePaths function
 *   Store selected multiple OOPs into an object tree.
 *
 *  Gemstone64, changes in error behavior : The existance of all objects in 
 *   newValues[] is checked before any path access  or path stores is
 *   attempted.  If one of the objects in newValues does not exist,
 *   or is not an objId allocated to the GCI, the failCount will be 1 .
 *
 *   For complete information, see the GCI Manual.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciStorePaths(
  const OopType theOops[], int numOops,
  const int paths[], const int pathSizes[],
  int  numPaths,
  const OopType newValues[],
  int *failCount 
    );

/* =============================================================================
 * GciStoreTrav function
 *   Store multiple traversal buffer values in objects.
 *
 *   For complete information, see the GCI Manual.
 *   For definitions of "flag", see  GCI_STORE_TRAV constants in gci.ht
 *   See also the comments for GciProcessDeferredUpdates .
 *==============================================================================
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(void) 
GciStoreTrav( GciTravBufType *travBuff, int flag);

/* =============================================================================
 * GciStrToPath function
 *
 *  Deprecated.
 *
 *   Convert a path representation from string to numeric.
 *
 *   For complete information, see the GCI Manual.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciStrToPath(
  OopType aClass,
  const char pathString[], int64 maxPathSize,
  int *resultPathSize, int resultPath[] 
    );

/* =============================================================================
 * GciStringToInteger function
 *
 *  Convert a String to a SmallInteger or LargeInteger .
 *
 *  Leading blanks are ignored.  Trailing non-digits are ignored.
 *  If the format of the argument string is invalid, the function result
 *  will be OOP_NIL and *no* error will be returned by GciErr.
 *
 *  This call does an RPC to the gem if the gem is remote.
 *==============================================================================
 */
  EXTERN_GCI_DEC(OopType) 
GciStringToInteger(const char* string, int64 stringSize);

/* ==========================================================================
 * Gci functions for operating on SymbolDictionaries & SymbolKeyValueDictionaries.
 *  These functions provide the equivalent of Smalltalk 
 *        at:put:, at:, and assocationAt:
 *  semantics.
 *  If theDict argument is not an instance of SymbolDictionaries or a
 *  subclass thereof, these generate an error.
 *  To operate on kinds of Dictionaries other than SymbolDictionaries,
 *  or SymbolKeyValueDictionaries, use GciPerform .
 *  If your dictionaries will be large ( > 20 elements) KeyValueDictionaries
 *  are recommended.
 * ==========================================================================
 */

/* ==========================================================================
 * GciSymDictAt
 *
 * Equivalent to GciSymDictAtObj except that the key is a C string instead of
 *  an object.
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciSymDictAt(
  OopType theDict, const char *keyString,
  OopType *value, OopType *association
    );

/* ==========================================================================
 *  GciSymDictAtObj
 *
 *  returns the value in SymbolDictionary theDict corresponding to key
 *  keyObj.  If an error occurs or keyObj is not found value is  OOP_ILLEGAL.
 *  If association is not NULL and an error does not occur,  stores
 *  the oop of the association for keyObj at *assocation, or stores
 *  OOP_ILLEGAL if keyObj was not found.
 *  Equivalent to Smalltalk 
 *    ^ #[ theDict at:keyObj,  theDict: associationAt:keyObj]
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciSymDictAtObj(
  OopType theDict, OopType keyObj,
  OopType *value, OopType *association
    );

/* ==========================================================================
 *  GciSymDictAtObjPut
 *
 *  Adds object theValue to the dictionary theDict with key keyObj.
 *  Equivalent to Smalltalk 
 *        theDict at: keyObj put: theValue
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciSymDictAtObjPut(OopType theDict, OopType keyObj, OopType theValue);

/* ==========================================================================
 *  GciSymDictAtPut
 *
 *  Equivalent to GciSymDictAtObjPut, except the key is a C string and not
 *  an object.
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciSymDictAtPut(OopType theDict, const char *keyString, OopType theValue);

/* ==========================================================================
 * GciStrKeyValueDictAt
 *
 * Equivalent to GciStrKeyValueDictAtObj except that the key is a C string
 * instead of an object.
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStrKeyValueDictAt(OopType theDict, const char *keyString, OopType *value);

/* ==========================================================================
 *  GciStrKeyValueDictAtObj
 *
 *  returns the value in StringKeyValueDictionary theDict corresponding to key
 *  keyObj.  If an error occurs or keyObj is not found value is  OOP_ILLEGAL.
 *  KeyValueDictionaries do not have associations, so no association is returned.
 *  Equivalent to Smalltalk 
 *    ^ #[ theDict at:keyObj]
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStrKeyValueDictAtObj(OopType theDict, OopType keyObj, OopType *value);

/* ==========================================================================
 *  GciStrKeyValueDictAtObjPut
 *
 *  Adds object theValue to theDict with key keyObj.
    theDict must be a kind of StringKeyValueDictionary. 
 *  Equivalent to Smalltalk 
 *        theDict at: keyObj put: theValue
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStrKeyValueDictAtObjPut(OopType theDict, OopType keyObj, OopType theValue);

/* ==========================================================================
 *  GciStrKeyValueDictAtPut
 *
 *  Equivalent to GciStrKeyValueDictAtObjPut, except the key is a C string and not
 *  an object.
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciStrKeyValueDictAtPut(
  OopType theDict, const char *keyString,
  OopType theValue
    );

/* =============================================================================
 * GciTraverseObjs function
 *   Traverse an array of GemStone objects.
 *
 *   For complete information, see the GCI Manual.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciTraverseObjs(
  const OopType theOops[], int numOops,
  GciTravBufType *travBuff,
  int level
    );

/*========================================================================
 * GciTrackedObjsFetchAllDirty
 *
 *    This function may only be called if both GciDirtyObjsInit() and
 *    GciTrackedObjsInit() have been called at least once during the session.
 *
 *	OopType exportedDirty (INPUT  OUTPUT)
 *		Must be an instance of IdentitySet or IdentityBag .
 *    		The ExportedDirtyObjs set is destructively enumerated into
 *              this NSC .
 *
 * 	int   numExportedDirty (OUTPUT)
 *		Pointer to a int which will return the number of objects in
 *       	the exportedDirty collection.
 *
 *	OopType trackedDirty (INPUT OUTPUT)
 *		Must be an instance of IdentitySet or IdentityBag .
 *		The TrackedDirtyObjs set is destructively enumerated into
 *              this NSC.
 *
 * 	long   numTrackedDirty (OUTPUT)
 *		Pointer to a long which will return the number of objects in
 *       	the exportedDirty collection.
 *
 *========================================================================
 */
  EXTERN_GCI_DEC(void)
GciTrackedObjsFetchAllDirty(OopType exportedDirty, int64 *numExportedDirty, 
		     OopType trackedDirty,  int64 *numTrackedDirty);

/*========================================================================
 * GciFilteredDirtyObjs - deleted
 */

/*========================================================================
 * GciTrackedObjsInit
 *
 *    Reinitializes the TrackedDirtyObjs set maintained by the system.
 *
 *    Must be called once after login before GciSaveAndTrackObjs can be called.
 *========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciTrackedObjsInit(void);

/* GciProduct returns an 8-bit unsigned integer indicating the
 * GemStone/S product to which the client library
 * belongs. Currently-defined integers are:
 *
 *   1  GemStone/S
 *   2  GemStone/S 2G
 *   3  GemStone/S 64
 *
 * Any future products in the GemStone/S line will be assigned integers
 * greater than three. Zero is reserved, and will never be assigned to
 * any product.
 *
 * GciProduct is not present in GemStone/S 6.1.3 and earlier, nor in
 * GemStone/S 2G versions 1.1 and earlier. It should be present in all
 * other products and versions.
 */
  EXTERN_GCI_DEC(unsigned char)
GciProduct(void);

/* GciVersion
 * Will return a 0 terminated string that describes the GCI version.
 * Version fields in the string will be delimited by a '.'. 
 * The first field is the major version number, 
 * the second field is the minor version number.
 * Any number of additional fields my exist. These
 * additional fields will describe the exact release of the GCI.
 * For additional version information use the methods in class System 
 * in the 'Version Management' category.
 */
  EXTERN_GCI_DEC(const char*)
GciVersion(void);

/*++++++++++++ User Action Functions ++++++++++++*/

/* =============================================================================
 * GciInUserAction function
 *   Determine whether or not the current process is executing a user action.
 *
 * Return Value:
 *   This function returns TRUE if it is called from within a user action, and
 *   FALSE otherwise.
 *==============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciInUserAction(void);

/*========================================================================
 * GCI   User Action typedef and data structure
 *                  The name must be the first element of the
 *                  GciUserActionSType; because the hash table utilities
 *                  depend upon it.
 *========================================================================
 */

/* this type MUST NOT have a function prototype; it is invoked with zero
   or more args */

/* =============================================================================
 * GciInstallUserAction function
 *   Associate a C function with a SmalltalkDB user action.
 *
 * Input Arguments:
 *   userAction	A pointer to a C structure that describes the user-written C
 *              function.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciInstallUserAction(GciUserActionSType *userAction);

  EXTERN_GCI_DEC(void) 
GciInstallUserAction_(GciUserActionSType *userAction, BoolType errorIfDuplicate);

  EXTERN_GCI_DEC(void)
GciDeclareAction(const char* name, void* func, int nargs, uint flags,
		 BoolType errorIfDuplicate);

/* =============================================================================
 * GciRaiseException function
 *   Signal an error, synchronously, within a user action.
 *
 *   Within a user action, causes control to return to Smalltalk.
 *   Outside of a user action, this function has no effect.
 *
 * Input Arguments:
 *   err	A pointer to the error type to raise.
 *   The elements of err->args are filtered as follows:
 *     If an arg is not a legal instance of OopType, it may be changed
 *     to a SmallInteger, or error 2101 may be generated.
 *     Remember that C longs must be passed through GciI32ToOop or
       GciI64ToOop  before assigning them to an element of err->args.
 *   If err->category is not a legal instance of OopType, it may be changed to
 *   OOP_GEMSTONE_ERROR_CAT before processing the error.  err->category should
 *   be either OOP_GEMSTONE_ERROR_CAT, or the oop of a user defined error
 *   category dictionary.
 *==============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciRaiseException(const GciErrSType *err);


/*
 * GciLoadUserActionLibrary
 *
 * Load a user action library.
 * If 'name' does not contain a path then a standard user action library
 * search is done. The proper prefix and suffix are added to the basename
 * if they are needed.
 *
 * Returns FALSE if an error occurs and will fill 'infoBuf' with an
 * error message unless 'infoBuf' is NULL.
 * Otherwise returns TRUE. If a library is loaded libHandlePtr will
 * be set to a value that represents the loaded library if libHandlePtr
 * is not NULL.
 * If 'mustExist' is TRUE then a error will  generated if the library
 * can not be found.
 * If 'mustExist' is FALSE then the library does not need to exist.
 * In this case TRUE will be returned and libHandlePtr will be NULL
 * if the library does not exist and non-NULL if it exists.
 * If 'infoBuf' is not NULL and the library is successfully loaded
 * then infoBuf will be filled the name of the user action library.
 * 
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(BoolType)
GciLoadUserActionLibrary(
  const char* name, BoolType mustExist, void** libHandlePtr,
  char infoBuf[], int64 infoBufSize
  );


/* GciCompatiblityLevel returns the value of GCI_COMPAT_LEVEL. */
  EXTERN_GCI_DEC(int) 
GciCompatiblityLevel(void);

/* GciFeatureLevel returns the value of GCI_FEATURE_LEVEL. */
  EXTERN_GCI_DEC(int) 
GciFeatureLevel(void);

/* ========================================================================= */

/* GciGetAppIdent , GciSetAppIdent
 *
 * Result of GciGetAppIdent 
 * is the argument of the most recent call to GciSetAppIdent,
 * or zero if GciSetAppIdent has not been called
 */
  EXTERN_GCI_DEC(int) 
GciGetAppIdent(void);

  EXTERN_GCI_DEC(void) 
GciSetAppIdent(int val);


/* ==========================================================================
 *  GciGetLogger
 *      arguments: none
 *
 *	results:  function returns a pointer to function of type
 *         GciLogFuncType, which is a logger function used to send strings
 *         to a log stream.
 *
 *   If GciSetLogger has not been called by the application, a default
 *   logging function is returned with will write to stderr .
 * ==========================================================================
 */
  EXTERN_GCI_DEC(GciLogFuncType*) 
GciGetLogger(void);


/* ==========================================================================
 *  GciInitExeName
 *
 *  Allows a GCI application to communicate the name and location of its
 *  executable to the GCI layer. If this information is provided it
 *  will be used when the application searches for a user action library
 *  to load.
 *  On most systems the correct value to pass is 'argv[0]' from C's main.
 *  It is best if the string passed includes a full path to the executable
 *  but if this is not available just the name of the executable file is
 *  of value.
 *  This name will also be used as the basename of the application
 *  user action library that GciInit should will try to load.
 *
 *  NOTE: If used, GciInitExeName must be called before GciInit is called.
 * 
 *  NOTE: The value of 'exeName' is ignored on systems that have OS support
 *        for access to the executable's name.
 * ==========================================================================
 */

  EXTERN_GCI_DEC(void) 
GciInitExeName(const char *exeName);

/* ==========================================================================
 *  GciSetLogger
 *      arguments: pointer to function of type
 *         GciLogFuncType, which is a logger function used to send strings
 *         to a log stream.
 *
 *	results:  none
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciSetLogger(GciLogFuncType *newLogger );

  EXTERN_GCI_DEC(void) 
GciSetLoggerFlush(BoolType immediateFlush);

  EXTERN_GCI_DEC(BoolType) 
GciGetLoggerFlush(void);

/* ==========================================================================
 *  NOTE:
 *    This function is not an official part of the GCI interface and
 *    may be removed in the future.
 * 
 *  GciVerbose
 *
 *  Turns on/off the gci verbose mode. By default verbose is on (TRUE).
 *  Must be called before GciInit.
 *  If the verbose mode is turned off (value == FALSE) then the gci layer
 *  will not write any non-error information to stdout.
 *  When verbose mode is on non-error information is written to stdout,
 *  for example the banner that shows the GCI version.
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciVerbose(BoolType value);

/* ==========================================================================
 *  GciGetNet
 *      Fills stoneBuff with the NRS used to connect to the stone.
 *      Fills gemBuff with the NRS used to connect to the gem (if rpc).
 *
 *      arguments: stoneBuff will be filled with a 0 terminated string that
 *                   is the NRS used to connect to the stone.
 *               .   If stoneBuff is NULL it is not used.
 *                 stoneBuffSize is the size in bytes of the buffer.
 *                 gemBuff will be filled with a 0 terminated string that
 *                   is the NRS used to connect to the gem (rpc only).
 *               .   If gemBuff is NULL it is not used.
 *                 gemBuffSize is the size in bytes of the buffer.
 *      
 *	results:  FALSE if Network Resource Strings could not be
 *                constructed from data given in a GciSetNet call.
 *                TRUE otherwise.
 * ==========================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciGetNet(
  char stoneBuff[], int64 stoneBuffSize,
  char gemBuff[], int64 gemBuffSize
    );

/* ============================================================================
 * GciGetNetldiFromNrsAll
 *
 *   If the environment variable GEMSTONE_NRS_ALL is defined
 *   and the value conforms to Gemstone NRS syntax and 
 *   the value defins a netldi name, return that value in *result
 *   and function result will be TRUE.
 *   otherwise store *result = '\0'; and function result is FALSE;
 *   used in topaz implementation of -n argument
 * ==========================================================================
 */
 EXTERN_GCI_DEC(BoolType)
GciGetNetldiFromNrsAll(char* result, size_t resSize);


/* ============================================================================
 * GciSessionInUse function
 *   Returns TRUE if 'sessionId' is in use. Returns FALSE otherwise.
 *
 * Input Arguments:
 *   sessionId	The session ID of session to check.
 *=============================================================================
 */
  EXTERN_GCI_DEC(BoolType) 
GciSessionInUse(GciSessionIdType sessionId );

typedef uint64 GciClientDataType;
typedef void GciLoginCallbackFuncType(GciSessionIdType id, BoolType isLogin,
				      GciClientDataType clientData);

extern "C" {

typedef BoolType GciOopMapCallbackFuncType(GciOopMapEntryType entry, 
	int64 *arg1, int64* arg2);
}

/*
 * GciSetLoginCallback allows a GCI application to find out about logins
 * and logouts that happen outside of its domain. For example if a user
 * action does a GciLogin then GciSetLoginCallback allows the application
 * to find out a new session has been created.
 *
 * The function designated by 'callbackPtr' will be called just after
 * each GciLogin logs in and just before each GciLogout logs out.
 * It will be called with the following parameters:
 *   1. the value of GciGetSessionId() at the time of the call
 *   2. TRUE if logging in; FALSE if logging out
 *   3. the value of 'clientData'.
 *
 * NOTE: Any previous callback will be replaced by the new one.
 */
  EXTERN_GCI_DEC(void) 
GciSetLoginCallback(
  GciLoginCallbackFuncType* callbackPtr,
  GciClientDataType clientData
  );

/* The following GciOopMap* calls allow you to create a structure that
 * will map an OopType to some client data. The client data can be
 * a pointer or a value that can be represented in sizeof(void*) bytes.
 * The type GciOopMapType represents the oop map data structure.
 * The type GciOopMapEntryType represents a entry in the oop map.
 * Each entry consists of a key (the oop) and a value.
 * The type GciClientDataType represents the value that can be associated
 * with a oop.
 */

/* GciOopMapCreate returns NULL on failure , including on malloc failure
 */
  EXTERN_GCI_DEC(GciOopMapType)
GciOopMapCreate(void);

/* GciOopMapDestroy: frees up a created oopMap.
 */
  EXTERN_GCI_DEC(void)
GciOopMapDestroy(GciOopMapType map);

/*  GciOopMapEntryAdd  locates the entry corresponding to 'oop',
    creating a new entry in 'map' if there
    wasn't already one with the given oop.  If an entry already
    existed with the given oop then '*newPtr' is set to FALSE.
    If a new entry was created, then '*newPtr' is set to TRUE
    and the value of the new entry will be set to 'value'.
    The return value is the entry, which may be used to retrieve
    and modify the entry's value or to delete the entry from 'map'.
 */
  EXTERN_GCI_DEC(GciOopMapEntryType)
GciOopMapEntryAdd(
  GciOopMapType map,
  OopType oop,
  GciClientDataType value,
  BoolType* newPtr
  );

/*  GciOopMapEntryFind  locates the entry corresponding to 'oop' in 'map'.
    Returns the entry if it is found.
    Returns NULL if it is not found.
 */
  EXTERN_GCI_DEC(GciOopMapEntryType)
GciOopMapEntryFind(GciOopMapType map, OopType oop);

/*
     GciOopMapForeach will execute 'callback' for each entry in 'map'
     all of the entries in 'map'.
     'callback' is passed each entry in an arbitrary order.
     If 'callback' returns FALSE GciOopMapForeach will not call it any more.
     Returns FALSE if 'callback' returns FALSE.
     Returns TRUE if 'callback' returns TRUE.
     Note: entries should not be added or deleted during this operation.
 */
  EXTERN_GCI_DEC(BoolType)
GciOopMapForeach(GciOopMapType map,GciOopMapCallbackFuncType* callback,
	int64 *arg1, int64* arg2);

/*
     GciOopMapEntryDelete will remove an existing entry from a
     map.  The memory associated with the entry itself will be
     freed, but the client is responsible for any cleanup associ-
     ated with the entry's value, such as freeing a structure
     that it points to.
 */
  EXTERN_GCI_DEC(void)
GciOopMapEntryDelete(GciOopMapEntryType entry);

/*  GciOopMapEntryGetOop returns the oop associated with 'entry'.
 */
  EXTERN_GCI_DEC(OopType)
GciOopMapEntryGetOop(GciOopMapEntryType entry);

/*  GciOopMapEntryGetValue returns the value associated with 'entry'.
 */
  EXTERN_GCI_DEC(GciClientDataType)
GciOopMapEntryGetValue(GciOopMapEntryType entry);

/*  GciOopMapEntrySetValue sets the value associated with 'entry'.
 */
  EXTERN_GCI_DEC(void)
GciOopMapEntrySetValue(GciOopMapEntryType entry, GciClientDataType value);

/* GciNbGetNotifyHandle
 * Returns a OS file descriptor that can be used by an application to
 * figure out when to call GciNbEnd.
 * Whenever the handle has something to read GciNbEnd should be called.
 * Returns -1 if a nonblocking notify handle is not available.
 * This is always the case if the GCI session is linked.
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(int)
GciNbGetNotifyHandle(void);

/* GciGetSignalHandle
 * Returns a OS file descriptor that can be used by an application to
 * figure out when to call GciPollForSignal.
 * Whenever the handle has something to read GciPollForSignal should be
 * called.
 * Precondition: GciPollForSignal() == FALSE
 * Returns -1 if a signal handle is not available.
 * Currently -1 is never returned but may be on future platforms that
 * do not support this type of handle.
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(int)
GciGetSignalHandle(void);

/* GciWaitOnHandle
 * If 'handle' is the result of the GciNbGetNotifyHandle function,
 * this call blocks until a pending nb call completes or the specified
 * number of milliseconds have elapsed.
 * In this case a result of TRUE means GciNbEnd should find a result ready.
 *
 * If 'handle is the result of GciGetSignalHandle, blocks until an 
 * event is available or until number of milliseconds have elapsed.
 * In this case a result of TRUE means GciPollForSignal should be called.
 *
 * If 'millisecsToWait' is -1 then wait forever (no timeout).
 * If 'millisecsToWait' is 0 then don't wait at all.
 * Returns TRUE if returning because an event was detected on the handle.
 * Returns FALSE if returning because of timeout or an error.
 */
  EXTERN_GCI_DEC(BoolType)
GciWaitOnHandle(int handle, int millisecsToWait);

// deleted GciInitNoSharedCache, GciUseSharedCache per fix 44138

/********************* Overlay Store Calls ************************/
  EXTERN_GCI_DEC(void)
GciOverlayReplaceOops(OopType theObj, const OopType theOops[],
		      int numOops);

  EXTERN_GCI_DEC(void)
GciOverlayStoreOops(OopType theObject, int64 startIndex,
		    const OopType theOops[], int numOops);

  EXTERN_GCI_DEC(void)
GciOverlayStoreNamedOops(OopType theObject, int64 startIndex,
			 const OopType theOops[], int numOops);


/****************** Allow GCI access to NetInfo module ******************/

/* GciServerInfoFType will be called with the server's:
 *   name, machine, kind, start date, name of user who started it, version,
 *   and log file name; all as strings; NULL if a value doesn't exist.
 *   Also integer values for port and pid. Also a flag will be true if
 *   the server process exists.
 */
typedef BoolType GciServerInfoFType(const char *name,
				    const char *machine,
				    BoolType exists,
				    const char* kind,
				    int port,
				    int pid,
				    const char* startDate,
				    const char* starter,
				    const char* version,
				    const char* logName,
				    const char* productDir,
				    const char* cmdLine,
				    const char* configFile1,
				    const char* configFile2);

/* GciServerFind
 * Looks for server 'name' on 'machine'.
 * If machine is NULL then look on local machine.
 * If result > 0 and 'callback' is not NULL then 'callback' will be called
 * with parameters specifying information on the found server.
 * If result == 0 then if errBuf is not NULL it will be filled with a msg.
 * Returns 0 if an error, -1 if server does not exist,
 *         2 if server was killed, 1 if server exists.
 */
  EXTERN_GCI_DEC(int) 
GciServerFind(const char* name, const char* machine,
	      GciServerInfoFType* callback,
	      char errBuf[], int errBufSize);

/* GciServerForeach
 * Foreach server on 'machine' call 'callback'.
 * Returns the number of servers found.
 * Returns -1 and fills errBuf (if not NULL) on an error.
 */
  EXTERN_GCI_DEC(int) 
GciServerForeach(const char* machine, GciServerInfoFType* callback,
		 char errBuf[], int errBufSize);

/* GciServerPing
 * Try to connect to server at network 'port' on 'machine'.
 * If machine is NULL then look on local machine.
 * Will only wait 'secondsToWait' for the server to respond.
 * If 'secondsToWait' <= 0 then waits for a default number of seconds.
 * Returns 1 if server responded ok.
 * Returns -1 if server says it was not accepting any more clients.
 * Returns -2 if ping timed out.
 * Returns -3 if server did not respond.
 */
  EXTERN_GCI_DEC(int) 
GciServerPing(int port, const char* machine, int secondsToWait);

/* GciServerClean
 * Removes stale information kept about server 'name' on 'machine'.
 * If machine is NULL then use local machine.
 * NOTE: should only be called if server has been killed as reported by
 *       GciServerFind.
 * Returns TRUE if cleaned up ok.
 * Returns FALSE if an error with message in errBuf (if it is not NULL).
 */
  EXTERN_GCI_DEC(BoolType)
GciServerClean(const char* name, const char* machine,
	       char errBuf[], int errBufSize);


/* =======================================================================
 * GciDisassemble
 *
 *  Used by topaz for decompiling methods.  Has no effect in 
 *  customer executables.  If session is remote, output goes to stdout
 *  of the remote gem, otherwise to topaz linked session stdout
 * =======================================================================
 */
  EXTERN_GCI_DEC(void)
GciDisassemble(OopType aGsMethodOrCode);

/* =============================================================================
 * GciClassRemoveAllMethods
 *
 *  Remove all methods from the method dictionary of the specified class.
 *  For use in implementation of topaz.
 *
 *  Argument is the class whose method dictionary is to be cleared.
 * =============================================================================
 */
  EXTERN_GCI_DEC(void) 
GciClassRemoveAllMethods(OopType aClass);

/* ==========================================================================
 *  GciProtectMethods
 *    if mode is TRUE, all subsequent method compilations in the
 *    current session will require a <protected> or <unprotected> token.
 *    until the function is called again with mode FALSE.
 *  
 *    if mode is TRUE and the session is not logged in as SystemUser,
 *    the error RT_ERR_MUST_BE_SYSTEMUSER is generated, and no action is taken.
 * ==========================================================================
 */
  EXTERN_GCI_DEC(void) 
GciProtectMethods(BoolType mode);

/* GciStoreClientData causes the client data for session 'id'
 * to be 'clientData'.
 * If 'autoFree' is TRUE then the GCI will call free() when the session
 * is no longer used. Otherwise the client is responsible for doing a
 * free if needed.
 * Returns TRUE on sucess.
 * Returns FALSE if current session is not a valid session.
 */
  EXTERN_GCI_DEC(BoolType)
GciStoreClientData(GciSessionIdType id, void* clientData, BoolType autoFree);

/* GciGetClientData returns a pointer to the client data associated with
 * session 'id'. The association is created by GciStoreClientData.
 * Returns NULL if no association exists or current session is not valid.
 */
  EXTERN_GCI_DEC(void*)
GciGetClientData(GciSessionIdType id);

/* GciGetCBuffer returns a pointer to a fedBufferType.
 * This is used for a generalized buffer mechanism from SmalltalkDB.
 * Returns NULL if no buffer exists for the given Smalltalk object.
 */
  EXTERN_GCI_DEC(void*)
GciGetCBuffer(OopType gsBuffer);

/* GciStoreTravDo
 * The call will do a GciStoreTrav, GciPerformNoDebug or
 * GciExecuteStrFromContextDbg, and a GciAlteredObjs.
 * Returns the oop returned by the perform/execute.
 * Returns OOP_NIL on failure.
 */
  EXTERN_GCI_DEC(OopType)
GciStoreTravDo_(GciStoreTravDoArgsSType *args);

  EXTERN_GCI_DEC(void)
GciNbStoreTravDo_(GciStoreTravDoArgsSType *args);

/* GciStoreTravDoTrav
 * The call will do a GciStoreTrav, GciPerformNoDebug or
 * GciExecuteStrFromContextDbg, and a GciAlteredObjs.
 * Also does a GciClampedTrav.
 * Function result is the boolean  "moreTraversal" from
 * the GciClampedTrav part of the operation.
 */
  EXTERN_GCI_DEC(BoolType)
GciStoreTravDoTrav_(GciStoreTravDoArgsSType *stdArgs, GciClampedTravArgsSType *ctArgs);

  EXTERN_GCI_DEC(void)
GciNbStoreTravDoTrav_(GciStoreTravDoArgsSType *stdArgs, GciClampedTravArgsSType *ctArgs);

/* GciStoreTravDoTravRefs
 *
 * GciStoreTravDoTravRefs is not designed for use within a user action.
 *
 * This call  has several phases
 *  Phase 1
 *   Sends the oopsNoLongerReplicated, oopsGcedOnClient to the server, 
 *     server removes oopsGcedOnClient from both PureExportSet and ReferencedSet,
 *       if an oop in oopsGcedOnClient is in neither PureExportSet nor ReferencedSet,
 *       or specifies a non-existant non-special object, no error is generated.
 *     server removes oopsNoLongerReplicated from the PureExportSet and
 *        adds them to the ReferencedSet .
 *       If any non-special object in oopsNoLongerReplicated 
 *         was not actually in the PureExportSet, an error will be generated.
 *
 *  Phase 2, per the stdArgs  does GciStoreTrav 
 *
 *  Note, stdArgs->alteredNumOops is ignored on input  .
 *   The output value of stdArgs->alteredNumOops is always zero, 
 *   since altered objects are explicitly included in the traversal result.
 *
 *  Phase 3, the execution phase does one of
 *   GciPerformNoDebug, GciExecuteStrFromContextDbg, ExecuteBlock ,
 *     or no execution  .
 *     See GciStoreTravDoArgsSType in gcicmn.ht for ExecuteBlock variant .
 *     This phase always uses GCI_PERFORM_RESULT_INTO_REFSET, to put
 *     non-special execution results into the ReferenceSet; the result may also
 *     be added to the PureExport set during the traversal phase below.
 *
 *  Phase 4 , does a special GciClampedTrav .  The root of this traversal will
 *   be two objects (one object if Phase 3 was "no execution")
 *   The first root object (-->Phase 4A) is an array of all of the objects that
 *   would have been returned from a GciAlteredObjs call after Phase 3.
 *   The second root object (--Phase 4B)  is the execution result from Phase 3 .
 *   Phases 4A, 4B use the same clamp spec specified by *ctArgs.
 *   Phase 4A operates with level == (ctArgs->level + 1) , Phase 4B operates
 *   with ctArgs->level .
 *  
 *   Objects reported during Phase 4A are objects in the PureExportSet that 
 *   were changed since the more recent of the last GciStoreTravDoTravRefs
 *   or the last time the dirty object sets were cleared, plus any child
 *   objects not already in the PureExportSet .
 *
 *   Objects reported during Phase 4B are those objects not already in 
 *   PureExportSet
 *
 *   Execution result is not automatically put in PureExportSet; it is handled as
 *     per the traversal.
 *   Objects referenced by the execution result that are in the PureExportSet 
 *     are not reported, however they are not clamped and traversal is continued 
 *     through them to the level specified by the clamp specification.
 *   Objects for which the ctArgs cause a full report to be sent are added to the
 *     PureExportSet if not already in the PureExportSet .
 *   Objects for which the ctArgs would cause a header-only report to be sent,
 *        if an obj is in PureExportSet, report nothing
 *        else if obj not already in ReferencedSet, generate a header only report
 *              and add to ReferencedSet
 *
 *   All instVar values in object reports that are non-special and 
 *     not otherwise reported and not in the PureExportSet 
 *     are added to the ReferencedSet for both the
 *     altered objects and the execution result traversals.
 *
 *   The addSubleafHeaders instVar of the ctArgs->clampSpec object
 *   controls whether header-only reports are sent for instVar values
 *   at the bottom level of the traversal.
 *
 *   This function always sets GCI_TRAV_WITH_REF_SET bit in ctArgs->retrievalFlags.
 *
 * Function result is an int
 *   0 = traversal completed ,
 *   1 = traversal buffer full. Must use GciMoreTraversal() to finish traversal 
 *
 * The ReferencedSet protects its elements from GC ,
 *   but does not prevent committed objects from being faulted out of memory.
 *   There is no dirty tracking done on the ReferencedSet . The ReferencedSet
 *   represents those objects for which the GBS may have created a stub .
 *
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(int)
GciStoreTravDoTravRefs_(
  const OopType *oopsNoLongerReplicated, int numNotReplicated,
  const OopType *oopsGcedOnClient, int numGced,
  GciStoreTravDoArgsSType *stdArgs, GciClampedTravArgsSType *ctArgs);

  GCI_ALIGN_STACK EXTERN_GCI_DEC(void)
GciNbStoreTravDoTravRefs_(
  const OopType *oopsNoLongerReplicated, int numNotReplicated,
  const OopType *oopsGcedOnClient, int numGced,
  GciStoreTravDoArgsSType *stdArgs, GciClampedTravArgsSType *ctArgs);

/* Was used by GciRtlUnload to free up any resources the shared library
 * GCI may have allocated.
 */
  EXTERN_GCI_DEC(void)
GciUnload(void);

/* If the OS supports two user id's this call causes the process
 * to switch to the 'real' user id.
 */
  EXTERN_GCI_DEC(void)
GciUseRealUid(void);

/* If the OS supports two user id's this call causes the process
 * to switch to the 'effective' user id.
 */
  EXTERN_GCI_DEC(void)
GciUseEffectiveUid(void);

/* Encrypts the clear text 'password'. Puts the encrypted form in
 * outBuff and returns a pointer to the first character.
 * Returns NULL if outBuff is not large enough.
 */
  EXTERN_GCI_DEC(char*)
GciEncrypt(const char* password, char outBuff[], unsigned int outBuffSize);

/* Just like GciSetNet except the HostPassword can be encrypted. */
  EXTERN_GCI_DEC(void) 
GciSetNetEx(
  const char StoneName[],
  const char HostUserId[],
  const char HostPassword[],
  const char GemService[],
  BoolType passwordIsEncrypted
  );

/* GciSetNetEx_
 *  Returns FALSE if there is a syntax error in StoneName or GemService,
 *  with  details in *errString, otherwise returns TRUE.
 */
  EXTERN_GCI_DEC(BoolType)
GciSetNetEx_(const char *StoneName, const char *HostUserId,
           const char *HostPassword, const char *GemService,
           BoolType passwordIsEncrypted,
           char *errString, size_t maxErrSize);

/* GciSetNetEx__
 * Returns FALSE if there is a syntax error in StoneName or GemService,
 * with details in *errString, otherwise returns TRUE.
 */
  EXTERN_GCI_DEC(BoolType)
GciSetNetEx__(const char *StoneName, const char *HostUserId,
           const char *HostPassword, const char *GemService,
           BoolType passwordIsEncrypted,
           char *errString, size_t maxErrSize, const char* netldiName);

/* Just like GciLogin except it supports loginFlags.
 * loginFlags is a bit set. Legal bits are GCI_LOGIN_*.
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(BoolType) 
GciLoginEx(
  const char gemstoneUsername[], const char gemstonePassword[],
  unsigned int loginFlags, int haltOnErrNum
  );

  EXTERN_GCI_DEC(BoolType) 
GciNbLoginEx(
  const char gemstoneUsername[], const char gemstonePassword[],
  unsigned int loginFlags, int haltOnErrNum
  );

/* GciGetClearAllTempsCount
 *  return the current counter of how many times all temp objects have been
 *  cleared since login.   Used by topaz to determine whether its session
 *  state is valid after getting an error from gem .
 */
  EXTERN_GCI_DEC(int)
GciGetClearAllTempsCount(void);


/****** Begin Host Wrappers ***************************************************/
/* The following section is wrapper functions so that applications
 * get all the prototypes they need from gcipriv.hf.
 * See gciprivm.hf for some convenience macros.
 */

  EXTERN_GCI_DEC(void)
GciErrMsgWriteError(
    GciErrMsgPrintFType *msgRoutine,
    GciErrMsgObjPrintFType *objPrinter,
    GciErrSType *theError,
    int errNum, BoolType displayOops, int errsInProgress);

  EXTERN_GCI_DEC(BoolType)
GciHelp(const char fileName[],
        const char cmd[], 
        GciHelpReadLineFType *inputRoutine,
        GciHelpWriteLineFType *outputRoutine, const char* baseName);

  EXTERN_GCI_DEC(void) 
GciVerBanner(FILE* f, const char *pgmname,
	     const char *pgmdesc, const char *pgmversion);

  EXTERN_GCI_DEC(void) 
GciVerBannerP(FILE* f, const char *pgmname,
	     const char *pgmdesc, const char *pgmversion,
	     BoolType gemPatents);

  EXTERN_GCI_DEC(void) 
GciVerEndEdge(FILE* f);

  EXTERN_GCI_DEC(void)
GciVerDashVPrint(FILE* f, const char* progName);

  EXTERN_GCI_DEC(char*) 
GciUtlCtime(time_t t, GciCTimeStringType *result);

  EXTERN_GCI_DEC(void) 
GciTimeStampMsStr(time_t seconds, unsigned short milliSeconds,
		char *result, size_t resultSize);

  EXTERN_GCI_DEC(void) 
GciUtlSetExeDir(const char *argv0);

  EXTERN_GCI_DEC(int) 
GciUtlPartialStrCmp(const char *str1, const char *str2);

  EXTERN_GCI_DEC(int) 
GciUtlPartialStrCmp_(const char *str1, const char *str2, ssize_t *prefixLen);

  EXTERN_GCI_DEC(void) 
GciUtlExit(int status);

  EXTERN_GCI_DEC(void*) 
GciUtlMalloc(size_t length, const char reason[]);
   // calls HostCallDebugger if underlying malloc fails

  EXTERN_GCI_DEC(void*) 
GciUtlMalloc_(size_t length, const char reason[], int lineNum);
   // calls HostCallDebugger if underlying malloc fails

  EXTERN_GCI_DEC(void*) 
GciMalloc(size_t length, int lineNum );
   // returns NULL if underlying malloc fails

  EXTERN_GCI_DEC(void) 
GciCHeapCheck(void);

/* GciGemTrace
    For use in debugging the implementation or client code.
    To be called after GciLogin , argument values are
      level = 0 none, 1 commands, 2 commands+args , 3 even more
    Function result is previous value of the tracing state.
    When called with level > 0 starts tracing in both the client
    and gem process.  The gem process will write trace information to
    it's log file; the libgcirpc.so will write trace information
    to a gci<pid>trace.log file in the current directory of the client process.
    When called with level == 0, shuts off tracing.

    Tracing may also be controlled by the GS_LGC_DEBUG environment variable,
      such as   export GS_LGC_DEBUG=1 
    in the environments of the GCI client and of the startnetldi .
    When started from the environment variable, tracing is started independently
    in the client and the gem processes, depending upon their respective
    environments.  For the gem, it's value of GS_LGC_DEBUG inherits from
    the netldi, which in turn is inherited from the environment of the
    startnetldi.
 */
  GCI_ALIGN_STACK EXTERN_GCI_DEC(int) 
GciGemTrace(int level);
   // GciGemTrace note
   // the printSendTrace() and printRecvTrace in linkgc.hc
   // may be sufficient in a slow build without needing GciGemTrace(1)

/*
 */
  EXTERN_GCI_DEC(void) 
GciFree(void* ptr);

#define GCI_FREE(aPtr) { \
  GciFree(aPtr); \
  aPtr = NULL; \
}

/* GciRealloc  returns NULL if underlying realloc() fails
 */
  EXTERN_GCI_DEC(void*)
GciRealloc(void *p, size_t length, int lineNumber, const char* fileName);

  EXTERN_GCI_DEC(FILE*)
GciUtlOpenFile(const char* fileName, const char* openMode,
	       char errBuff[], size_t errBuffSize);

  EXTERN_GCI_DEC(int)
GciHostCallDebugger(void);

  EXTERN_GCI_DEC(void)
GciHostExpandFileName(const char inbuf[], char outbuf[],
		   int64 outbufLength);

  EXTERN_GCI_DEC(void)
GciHostftell(FILE *filePtr, FLG_FILEPOS_TYPE *filePos);

  EXTERN_GCI_DEC(void) 
GciHostfseek(FILE *filePtr, const FLG_FILEPOS_TYPE *filePos);

  EXTERN_GCI_DEC(double) 
GciHostGetCpuTime(void);

  EXTERN_GCI_DEC(BoolType) 
GciHostGetEnv(const char inStr[], char outStr[], int64 outSize);

  EXTERN_GCI_DEC(BoolType) 
GciHostSetEnv(const char *name, const char *value);

  EXTERN_GCI_DEC(BoolType) 
GciHostTempFileSpec(char buff[], size_t buffSize);

  EXTERN_GCI_DEC(int)
GciHostCallDebuggerMsg(const char* msg);

  EXTERN_GCI_DEC(int)
GciHostCallDebuggerMsg_fl(const char* msg, const char* filename, int line);

  EXTERN_GCI_DEC(void) 
GciHostFtime(time_t *sec, unsigned short *millitm);

  EXTERN_GCI_DEC(void) 
GciHostInit(void);

  EXTERN_GCI_DEC(int) 
GciHostSilentGetLine(const char prompt[], char buf[], int64 maxLen);

  EXTERN_GCI_DEC(BoolType) 
GciHostSpawn(const char theCommand[]);

  EXTERN_GCI_DEC(int)
GciHostStrCmpi(const char *s1, const char *s2);

  EXTERN_GCI_DEC(BoolType) 
GciHostRemoveFile(const char *fileName , BoolType userFile);
  // Gs64 v2.0, on Unix, no longer supports wildcards '*' or '?' in fileName

  EXTERN_GCI_DEC(void)
GciHostInstallFaultHandler(GciFaultFuncType fileFlusher, GciFaultFuncType *shutdownFct);

  EXTERN_GCI_DEC(void) 
GciHostEnableKbInt(GciKbIntFType *routine);

  EXTERN_GCI_DEC(void)
GciHostSleep(unsigned int seconds);

  EXTERN_GCI_DEC(void)
GciHostMilliSleep(unsigned int milliSeconds);

  EXTERN_GCI_DEC(void)
GciHostNanoSleep(int64_t nanoseconds);

  EXTERN_GCI_DEC(BoolType) 
GciDllDbInConversion(void);

  EXTERN_GCI_DEC(void)
GciDllSetDbInConversion(BoolType);


  EXTERN_GCI_DEC(BoolType)
GciUnixIoStat(const char *filename, UnixIoStatSType *buf, char *errText, size_t errTextSize);

  EXTERN_GCI_DEC(int) 
GciUnixIoFgetc_(FILE *inFile);

  EXTERN_GCI_DEC(int) 
GciUnixIoFgets_(char* result, size_t resultSize, FILE *inFile);

  EXTERN_GCI_DEC(void)
GciUnixIoInterrupt(int v);

  EXTERN_GCI_DEC(void)
GciHostGuarantee(BoolType arg, const char* file, int line);

  EXTERN_GCI_DEC(int)
GciUtlToUpper(int c);

/****** End Host Wrappers ***************************************************/

  GCI_ALIGN_STACK EXTERN_GCI_DEC(int)
GciCompress(char *dest, uintptr_t *destLen,
             const char *source, uintptr_t sourceLen);

  GCI_ALIGN_STACK EXTERN_GCI_DEC(int)
GciUncompress(char *dest, uintptr_t *destLen,
	       const char *source, uintptr_t sourceLen);

  EXTERN_GCI_DEC(BoolType)
GciNscIncludesOop(OopType theNsc, OopType theOop);

  EXTERN_GCI_DEC(void)
GciSetVaryingSize(OopType collection, int64 size);

/* ===========================================================================
 *  GciSetHaltOnError
 *    cause this session to halt for internal debugging when the
 *    specified error occurs. If errNum = 0,  disables halt on error .
 *
 *    Result is the previous error number on which the session was to halt
 *
 * ===========================================================================
 */
  EXTERN_GCI_DEC(int) 
GciSetHaltOnError(int errNum);

/*========================================================================
 * GCI_FLOAT_CPY
 *   memcpy for 8 byte body of a instance of Float (copy a C double )
 */
void GCI_FLOAT_CPY(void* aDest, const void* aSrc);

/*========================================================================
 * GCI_SMALL_FLOAT_CPY
 *   memcpy for 4 byte body an instance of SmallFloat (copy a C float)
 */
void GCI_SMALL_FLOAT_CPY(void* aDest, const void* aSrc);


// =============================================================================
// Following generate errors if argument does not fit in result
// type or if argument is not an Integer.  Result will be zero if
// an error occurred.  
// GciErr() will reflect the error status

/* GciOopToI32 converts the argument to a C int if argument is a SmallInteger 
 *   within range of C int .
 * Returns 0 and generates an error if argument is not represenable as a C int64.
 * The error may be retrieved with GciErr() .
 */
  EXTERN_GCI_DEC(int) 
GciOopToI32(OopType arg);

/* GciOopToI64 converts the argument to a C int64 if argument is a SmallInteger 
 *   within range of C int64
 * Returns 0 and generates an error if argument is not represenable as a C int64.
 * The error may be retrieved with GciErr() .
 */
  EXTERN_GCI_DEC(int64) 
GciOopToI64(OopType arg);

// ============================================================================
// For following, if argument does not fit in result
// type or if argument is not an Integer, then *error set to TRUE .
// If successful then *error is not changed.

/* GciOopToI32_ 
 *  If argument is a SmallInteger within range of C int ,
 *  returns the C int and does not change the value of *error .
 *
 *  Returns 0 and sets *error to one if argument is not represenable as a C int.
 */
EXTERN_GCI_DEC(int) 
GciOopToI32_(OopType arg, BoolType *error/*output*/);
   // convert arg to an int if arg is a SmallInteger within range of C int

/* GciOopToI64_ 
 *  If argument is a SmallInteger within range of C int64 ,
 *  returns the C int64 and does not change the value of *error .
 *
 *  Returns 0 and sets *error to one if argument is not represenable as a C int64.
 */
EXTERN_GCI_DEC(int64) 
GciOopToI64_(OopType arg, BoolType *error/*output*/);

/* ===============================================================
  GciServerIsBigEndian
    Returns TRUE if session is RPC and server process is big-endian,
    or if session is linked and this process is big-endian.
    Returns FALSE otherwise.
    Generates an error if current session is invalid.
 */
EXTERN_GCI_DEC(BoolType)
GciServerIsBigEndian(void);

/* ===============================================================
 *  GciSetTraversalBufSwizzling
   If argument is TRUE, enable normal byte-order swizzling of 
   traversal buffers for the current RPC session , which is the
   default state for a session created by successful GciLogin().
   If argument is FALSE,  the application program (i.e. GBS) is responsible
   for subsequent swizzling of traversal buffers if needed. 
   Function result is previous value of swizzling of traversal buffers .
   Returns FALSE and has no effect when called on the linkable session.
   Generates an error and returns FALSE if current session is invalid;
   This function controls swizzling of the traversal buffers used by
   these calls in an RPC session:
     GciStoreTrav, GciNbStoreTrav,
     GciStoreTravDo, GciNbStoreTravDo, 
     GciStoreTravDoTrav GciNbStoreTravDoTrav,     
     GciClampedTrav, GciNbClampedTrav,
     GciMoreTraversal, GciNbMoreTraversal,
     GciPerformTrav, GciNbPerformTrav,
     GciExecuteStrTrav, GciNbExecuteStrTrav
*/
EXTERN_GCI_DEC(BoolType)
GciSetTraversalBufSwizzling(BoolType enabled);

/* ===============================================================
 * GciOldOopToNewOop
      The argument must be a Gs64 v1.1 OopType .
      The result will be a Gs64 v2.0 OopType, or OOP_ILLEGAL if the
      argument is not a valid  Gs64 v1.1 OopType .

      If result is not a special oop, the existance of the object
      is not checked.  
      If argument is a special oop other than SmallInteger or SmallDouble,
      OOP_ILLEGAL will be returned if the argument is not a legal
      special oop, or the current session is not valid .

      There is no conversion of LargeIntegers to
      new SmallIntegers .   The result will never be a SmallDouble.
 */
EXTERN_GCI_DEC(OopType)
GciOldOopToNewOop(unsigned int oldOop);

/* ===========================================================================
 *  GciReadSharedCounterNoLock
 *    Read the value of the given shared counter without locking it.
 *    Faster but possiblly less accurate than the GciReadSharedCounter() 
 *    function.
 *
 *    Returns TRUE if successful, FALSE if an error occurred.
 *
 *    Not supported for remote GCI interfaces. 
 * ===========================================================================
 */
  EXTERN_GCI_DEC(BoolType)
GciReadSharedCounterNoLock(int counterIdx, int64_t *value);

/* ===========================================================================
 *  GciReadSharedCounter
 *    Read the value of the given shared counter after first locking it.
 *
 *    Returns TRUE if successful, FALSE if an error occurred.
 *
 *    Not supported for remote GCI interfaces. 
 * ===========================================================================
 */
  EXTERN_GCI_DEC(BoolType)
GciReadSharedCounter(int counterIdx, int64_t *value);

/* ===========================================================================
 *  GciIncSharedCounter
 *    Increment the value of the shared counter indicated by counterIdx.
 *    The contents of the value pointer indicates how much to increment the
 *    shared counter by.  When the function returns, value will store the new
 *    value of the counter after the increment.  A counter cannot be
 *    incremented to a value greater than INT_MAX (2147483647).  Attempts to
 *    do so will not cause an error but will set the counter to a value of 
 *    INT_MAX.
 *
 *    Returns TRUE if successful, FALSE if an error occurred.
 *
 *    Not supported for remote GCI interfaces. 
 * ===========================================================================
 */
  EXTERN_GCI_DEC(BoolType)
GciIncSharedCounter(int counterIdx, int64_t *value);

/* ===========================================================================
 *  GciDecSharedCounter
 *    Decrement the value of the shared counter indicated by counterIdx.
 *    The contents of the value pointer indicates how much to decrement the
 *    shared counter by.  When the function returns, value will store the new
 *    value of the counter after the increment.
 *
 *    floor points to an integer which indicates the minimum possible value
 *    of the counter.  The counter cannot be decremented below this value.
 *    If floor is NULL, then a floor of INT_MIN (-2147483648) will be used.
 *
 *    A counter cannot be decremented to a value less than INT_MIN 
 *    (-2147483648).  Attempts to do so will not cause an error but will set
 *    the counter to a value of INT_MIN.

 *    Returns TRUE if successful, FALSE if an error occurred.
 *
 *    Not supported for remote GCI interfaces. 
 * ===========================================================================
 */
  EXTERN_GCI_DEC(BoolType)
GciDecSharedCounter(int counterIdx, int64_t *value, int64_t *floor);

/* ===========================================================================
 *  GciSetSharedCounter
 *    Set the value of the shared counter indicated by counterIdx.
 *    The contents of the value pointer indicates the new value of the shared
 *    counter.  
 *
 *    Returns TRUE if successful, FALSE if an error occurred.
 *
 *    Not supported for remote GCI interfaces. 
 * ===========================================================================
 */
  EXTERN_GCI_DEC(BoolType)
GciSetSharedCounter(int counterIdx, int64_t *value);

/* ===========================================================================
 *  GciObjIsCommitted
 *    Returns TRUE if the object is committed, FALSE if not.  Special objects
 *    always return TRUE.  Objects that do not exist will return FALSE.
 *
 *    Not supported for remote GCI interfaces. 
 * ===========================================================================
 */
  EXTERN_GCI_DEC(BoolType)
GciObjIsCommitted(OopType oop);

/* ===========================================================================
 *  GciFetchSharedCounterValuesNoLock
 *    Fetch the value of multiple shared counters in a single call without
 *    locking any counters.
 *
 *    Arguments:
 *        startIndex - index of the first shared counter to fetch.  The first
 *                     counter has an index of 0.
 *        buffer -     pointer to a buffer where the shared counter values will
 *                     be stored.  Must be at least 8 * maxReturn bytes in size.
 *                     Buffer address must be aligned on a 8-byte boundary.
 *        maxReturn -  maximum number of counters to fetch values for.
 *
 *    Returns the number of elements (ints) actually stored in the buffer.  
 *    Returns -1 if a bad argument is detected.
 *
 *    Not supported for remote GCI interfaces. 
 * ===========================================================================
 */
  EXTERN_GCI_DEC(int)
GciFetchSharedCounterValuesNoLock(int startIndex, int64_t buffer[], size_t maxReturn);

/* ===========================================================================
 *  GciFetchNumSharedCounters
 *    Fetch the number of shared counters available for use to this session.
 *
 *    Returns -1 the session is not logged in.
 *
 *    Not supported for remote GCI interfaces. 
 * ===========================================================================
 */
  EXTERN_GCI_DEC(int)
GciFetchNumSharedCounters(void);

// ===========================================================================

  EXTERN_GCI_DEC(void)
 GciSwapBytesUshort(ushort *buf, intptr_t numChars);
  // swap byte order of specified array of ushort

  // 39484: for QBS support
  EXTERN_GCI_DEC(void)
 GciSwapBytesUint(uint *buf, intptr_t numChars);
  // swap byte order of specified array of uint


/* ===========================================================================
 * GciDynLib, GciSetDynLib
 * 
 *  GciDynLib returns the argument of the most recent call to GciSetDynLib,
 *  or returns NULL if GciSetDynLib has not been called.
 *
 *  May be used by a main program to save result of dlopen() which
 *  loaded the gci shared library.  
 */
  EXTERN_GCI_DEC(void)
GciSetDynLib(void *handle);

  EXTERN_GCI_DEC(void*)
GciDynLib(void);

/* ===========================================================================
 * GciKeyfilePermissions
 *  Result reflects the keyfilePermissions word from the stone process 
 */
  EXTERN_GCI_DEC(uint)
GciKeyfilePermissions(void);

// ===========================================================================
// dynamic instVars support added in Gs64 v3.0

/* GciFetchDynamicIvs
  Function result is number of oops returned in buf.
  The number of dynamic instVar pairs returned is function result / 2 .

  To obtain all dynamic instVars in one call, use a buffer
  OopType buf[GCI_MAX_DYNAMIC_IVS*2] 
 */
  EXTERN_GCI_DEC(int)
GciFetchDynamicIvs(OopType obj, OopType *buf, int bufSizeOops);

/* GciStoreDynamicIv
  Creates or changes the value of dynamic instVar specified by aSymbol
  within object obj . Dynamic instVars are not allowed in
  instances of ExecBlock, Behavior, GsNMethod, or special objects.
  To delete a dynamic instVar,  pass OOP_REMOTE_NIL as the value .
  See also Object>>dynamicInstVarAt:put:  .
 */
  EXTERN_GCI_DEC(void)
GciStoreDynamicIv(OopType obj, OopType aSymbol, OopType value);

/* GciFetchDynamicIv
 * Returns the value of the dynamic instVar specified by aSymbol.
 * Returns OOP_NIL if no such dynamic instVar exists in obj.
 */
  EXTERN_GCI_DEC(OopType)
GciFetchDynamicIv(OopType obj, OopType aSymbol);

/* GciFetchTagSize
 * Returns the number of oops of dynamic instVars that are allocated
 * in the object.  Returns 0 if obj is a special object.
 */
  EXTERN_GCI_DEC(int64)
GciFetchTagSize(OopType obj);


/* GciAllocTravBuf
  Allocates and initialize a new GciTravBufType structure.
  Use GciFree() to free the memory .
 */
  EXTERN_GCI_DEC(GciTravBufType *)
GciAllocTravBuf(size_t allocationSize);  /* Fix 39249 */

/* GciAll7Bit
   Returns TRUE if contents of str are all characters <= 127.
   strlen(str) is returned in *len . 
 */
 EXTERN_GCI_DEC(BoolType)
GciAll7Bit(const char* str, size_t *len);


}  /* extern "C" */

#include "gcisend.hf"
#include "gcifloat.hf"

/* =============================================================================
 * GCI_OOP_TO_BOOL
 *   Convert a Boolean object to a C Boolean value.
 *
 * Arguments:
 *   (1) The OOP of the Boolean object to be translated into a C Boolean value.
 *
 * Result value:
 *   A C Boolean value.  Returns the C Boolean value that corresponds to the
 *   GemStone object.  In case of error, this macro returns FALSE.
 *==============================================================================
 */
#define GCI_OOP_TO_BOOL(oop)  GciOopToBool(oop)

/* =============================================================================
 * GCI_OOP_TO_CHR macro
 *   Convert a Character object to a 8 bit  C character
 *
 * Arguments:
 *   (1) The OOP of the Character object to be translated into a C character
 *
 * Result value:
 *   A C char.   Generates an error if the argument is not an instance of
 *   Character, or is an instance outside of the range of a C char .
 *==============================================================================
 */
#define GCI_OOP_TO_CHR(oop) (GciOopToChr(oop))

/* =============================================================================
 * GCI_OOP_TO_CHAR macro
 *   Convert a Character object to a 32 bit  C character
 *
 * Arguments:
 *   (1) The OOP of the Character object to be translated into a C character
 *
 * Result value:
 *   A C unsigned int .
 *==============================================================================
 */
#define GCI_OOP_TO_CHAR(oop) GciOopToChar32(oop)

#endif /* GCI_HF */
